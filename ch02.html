<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>多项式的非交互式零知识证明 - zk-SNARK 为什么以及如何工作</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="《zk-SNARK 为什么以及如何工作（Why and How zk-SNARK Works）》简体中文版">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="abstract.html">摘要</a></li><li class="chapter-item expanded "><a href="ch01.html"><strong aria-hidden="true">1.</strong> 多项式的性质与证明</a></li><li class="chapter-item expanded "><a href="ch02.html" class="active"><strong aria-hidden="true">2.</strong> 多项式的非交互式零知识证明</a></li><li class="chapter-item expanded "><a href="ch03.html"><strong aria-hidden="true">3.</strong> 从程序到多项式的构造</a></li><li class="chapter-item expanded "><a href="ch04.html"><strong aria-hidden="true">4.</strong> 多项式的约束</a></li><li class="chapter-item expanded "><a href="ch05.html"><strong aria-hidden="true">5.</strong> Pinocchio 协议</a></li><li class="chapter-item expanded affix "><a href="references.html">参考文献</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">zk-SNARK 为什么以及如何工作</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/zyw271828/wahzw-zh-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="从零开始学习-zk-snark二多项式的非交互式零知识证明"><a class="header" href="#从零开始学习-zk-snark二多项式的非交互式零知识证明">从零开始学习 zk-SNARK（二）——多项式的非交互式零知识证明</a></h1>
<h2 id="限制多项式"><a class="header" href="#限制多项式">限制多项式</a></h2>
<p>上文说到，多项式的知识其实就是它的系数 <em>c<sub>0</sub>, c<sub>1</sub>, …, c<sub>i</sub></em> 的知识。协议中我们是通过对秘密值 <em>s</em> 的幂的加密值再进行求幂来对系数进行“赋值”。我们已经限制了 prover 对 <em>s</em> 幂的加密值的选择, 但是这个限制并不是强制的  ，也就是说，prover 可以使用任何可能的方法找到满足下面等式的值  <em>z<sub>p</sub></em> 和 <em>z<sub>h</sub></em> </p>
<p>$Z_p = (Z_h)^{t(s)}$</p>
<p>再用这两个值来代替  <em>gᵖ</em>  和 <em>gʰ</em>  将它交给 verifier。所以 verifier 需要能够证明 prover 给出的值就是用 <em>s</em> 幂的加密值而不是其它值计算出来的。</p>
<p>我们看一个由一个变量和一个系数组成的一阶多项式的简单例子，对应的 <em>s</em> 的加密值为 <em>E(s) = gˢ</em>。这里我们要做的就是确保 prover 是拿 <em>s</em> 的加密值，即 <em>gˢ</em> ，而不是其他值与系数 <em>c</em> 做同态相乘的。所以结果一定是这个形式（<em>c</em> 为任意值）：</p>
<p>$(g^s)^c$</p>
<p>解决这个问题的一种方法就是用另一个“变换”的加密值做同样的操作，充当类似算术中“校验和”<em>（Checksum）</em>  的作用，以此确保结果是原始值的求幂值。</p>
<p>这个是通过 <strong>Knowledge-of-Exponent Assumption (简称 KEA)</strong> 方法来实现的，在  [<a href="#bd26">Dam91</a>] 中有介绍，更精准一点（注意 <em>a</em> 和 <em>α</em>(alpha)这两个字符的不同）说：</p>
<p>a）Alice 有一个值 <em>a</em>，她想要 Bob 对其进行任意指数的求幂（这里 <em>a</em> 是一个有限域群的生成器），唯一的要求是只能对  <em>a</em> 进行求幂，为了保证这一点，她要：</p>
<ul>
<li>
<p>选择一个随机数 <em>α</em></p>
</li>
<li>
<p>计算 <em>a' = a <sup>α</sup>(mod n)​</em></p>
</li>
<li>
<p>提供一个元组 <em>(a, a')</em> 给 Bob, 然后让他对这两个值执行任意的求幂运算，返回结果元组 <em>(b, b')</em>，这里的指数 “α-变换” 依然保持不变，即 <em>b<sup>α</sup> = b'(mod n)​</em></p>
</li>
</ul>
<p>b) 因为 Bob 无法从元组 <em>(a, a')</em> 中提取 <em>α</em> 的值，通过暴力破解也难以实现，那就可以推断 Bob 生成有效元组的唯一方法就是执行下面的步骤：</p>
<ul>
<li>选择一个值 c</li>
<li>计算 b=(a)<sup>c</sup>(mod n) 和 b' = (a')<sup>c</sup> (mod n)</li>
<li>回复 <em>(b,b')</em></li>
</ul>
<p>c) 有了回复的元组和 <em>α</em>，Alice 就可以验证等式：</p>
<p><em>(b)<sup>α</sup> = b'</em></p>
<p><em>(a<sup>c</sup>)<sup>α</sup> = (a')<sup>c</sup></em></p>
<p><em>a<sup>c·α</sup> = (a<sup>α</sup>)<sup>c</sup></em></p>
<p>结论是：</p>
<ul>
<li>Bob 在元组的两个值的计算上都用了同一个指数（即 <em>c</em>）</li>
<li>Bob 只能用 Alice 原本的元组来保持 <em>α</em> 关系</li>
<li>Bob 知道指数 <em>c</em>，因为构造验证值 (<em>b,b</em>′) 的唯一方式是用同一个指数</li>
<li>Alice 并不知道 <em>c</em>，这和 Bob 不知道 <em>α</em> 的原因一样</li>
<li>虽然 <em>c</em> 是被加密的，但它的可能取值范围并不足够大到保持其零知识的性质，这个问题我们将在后面“零知识”那一节解决。</li>
</ul>
<p>最后这个协议提供了一个证明给 Alice ，Bob 确实是用他知道的某个值对 <em>a</em> 进行求幂的，而且他也不能做别的任何操作，例如：乘法，加法，因为这样就会破坏 α-变换关系。</p>
<p>在同态加密中，求幂是对被加密值进行乘法运算。我们可以应用这个结构到一个简单的系数多项式 <em>f</em>(<em>x</em>) = <em>c</em>⋅ <em>x</em>的例子中：</p>
<ul>
<li>
<p>verifier 选择随机数 <em>s</em>, <em>α</em>，然后提供令 <em>x=s</em> 的一阶及其转换的计算值：</p>
<p>$(g^s,g^{αs})$</p>
</li>
<li>
<p>prover 代入系数 c 计算:</p>
<p>$((g^s)^c,(g^{αs})^c) =(g^{cs},g^{αcs})$</p>
</li>
<li>
<p>verifier 验证：</p>
<p>$(g^{cs})^α = g^{αcs}$</p>
</li>
</ul>
<p>这个结构“限制” prover 只能用 verifier 提供的加密的 <em>s</em> 进行计算，因而 prover 只能将系数 c 赋给 verifier 提供的多项式。现在我们可以扩展这种单项式上的方法到多项式上，因为计算是先将每项的分配分开计算然后再 “同态地” 相加在一起的（这个方法是 Jens Groth 在 [<a href="#3068">Gro10</a>] 中介绍的）。所以如果给定 prover 一个指数为 <em>s</em> 的幂以及它们的变换的加密值，他就可以计算原始的和变换后的多项式，这里也必须要满足同样的校验。对于阶数为 <em>d</em> 的多项式：</p>
<ul>
<li>
<p>verifier 提供加密值 $g^{s^0}$,$g^{s^1}$,…,$g^{s^d}$ 和他们的变换  $g^{αs^0}$,$g^{αs^1}$,…,$g^{αs^d}$ </p>
</li>
<li>
<p>prover:</p>
<ul>
<li>
<p>计算给定的带有 s 的幂的加密多项式</p>
<p>$g^{p(s)} = (g^{s^0})^{c_0} \cdot (g^{s^1})^{c_1}……(g^{s^d})^{c_d} = g^{(c_0s^0+c_1s^1+…+c_ds^d) }$</p>
</li>
<li>
<p>计算给定的带有 s 的幂的转换的加密“转换”多项式：</p>
<p>$g^{αp(s)} = (g^{αs^0})^{c_0} \cdot (g^{αs^1})^{c_1}……(g^{αs^d})^{c_d} = g^(c_0αs^0+c_1αs^1+…+c_dαs^d) = g^α(c_0s^0+c_1s^1+…+c_ds^d) $</p>
</li>
<li>
<p>将计算结果 $g^p$,$g^{p'}$ 发给verfier</p>
</li>
</ul>
</li>
<li>
<p>verifier 校验：$(g^p)^α = g^{p'}$</p>
</li>
</ul>
<p>前面的多项式例子 <em>p(x) = x<sup>3</sup> - 3x<sup>2</sup> +2x</em> 就变成了：</p>
<ul>
<li>
<p>verifier 提供 $E(s^3)$, $E(s^2)$, $E(s)$ 和它们的变换  $E(αs^3)$, $E(αs^2)$, $E(αs)$ </p>
</li>
<li>
<p>prover 计算：</p>
<p>$g^p = g^{p(s)} = (g^{s^3})^1 \cdot (g^{s^2})^{(-3)} \cdot (g^s)^2 = g^{s^3} \cdot g^{-3s^2} \cdot g^{2s} = g^{s^3-3s^2+2s}$</p>
<p>$g^{p'} = g^{αp(s)} = (g^{αs^3})^1 \cdot (g^{αs^2})^(-3) \cdot (g^αs)^2 = g^{αs^3} \cdot g^{-3αs^2} \cdot g^{2αs} = g^{α(s^3-3s^2+2s)}$</p>
</li>
<li>
<p>verifier 校验：$(g^p)^α = g^{p'}$</p>
<p>$(g^{s^3-3s^2+2s})^α = g^{α(s^3-3s^2+2s)}$</p>
<p>$g^{α(s^3-3s^2+2s)} = g^{α(s^3-3s^2+2s)}$</p>
</li>
</ul>
<p>现在我们就可以确保 prover 是用了 verifier 提供的多项式而不是其它值做计算的了，因为别的方法不能够保持 α-变换。 当然如果 verifier 想要确保在 prover 的多项式中排除了 s 的某些次幂，如 j， 他就不提供对应的密文及其变换：</p>
<p>$g^{s^j}，g^{αs^j}$</p>
<p>与前面的协议相比，我们现在已经有了一个比较健壮的协议。但是尽管已经做了加密，在<em>零知识</em> 性质上也还依然存在一个很明显的缺陷：<em>即理论上多项式参数 c<sub>ᵢ</sub> 是一个很广的取值范围内的值，实际上这个范围可能很有限</em>（比如前面例子中的 6），这就意味着 verifier 可以在有限范围的系数组合中进行暴力破解，最终计算出一个与 prover 的答案相等的结果。比如我们将每个系数的取值范围定为 100，多项式阶数为 2，那么大概会有 100 万种不同的组合，这里可以认为暴力破解只需要少于 100 万次的迭代。更重要的是，即使在只有一个系数，值为 1 的例子中，安全协议也应该能够保证其安全。</p>
<blockquote>
<p>even@安比实验室: 有了 KEA，就可以约束 prover 只能通过用 verifier 提供的加密值去构造证明了。严格点讲，这里是用的是 KEA的扩展版本，叫做 The q-power Knowledge of Exponent Assumption. </p>
</blockquote>
<h2 id="零知识证明"><a class="header" href="#零知识证明">零知识证明</a></h2>
<p>因为 verifier 能够从 prover 发送的数据中提取未知多项式 <em>p(x)</em> 的知识 ，那么我们就来看一下这些提供的数据（证明）：</p>
<p>$g^p$，$g^{p'}$，$g^h$</p>
<p>它们参与到了下面的验证：</p>
<p>$g^p = (g^h)^{t(s)}$  (多项式  <em>p(x)</em> 有根 <em>t(x)</em>)</p>
<p>$(g^p)^α = g^{p'}$  (用了正确形式的多项式)</p>
<p>问题是我们如何选择证明使得这个校验依然有效，同时又保证没有知识能被提取？</p>
<p>前面章节给了我们一个答案：我们可以使用随机值 *δ (delta)*来“变换”这些值,  如 <em>(g<sup>p</sup> )<sup>δ</sup></em>。 现在，为了提取知识，就必须首先要知道一个不可知的值 <em>δ</em>。并且，这种随机化在统计学上与随机值没有什么区别。</p>
<p>为了保持这种关系，我们在 verifier 的检查中验证一下。等式的每一边都有一个 prover 提供的值。所以如果我们用同一个<em>δ</em> 来“变换” 每一个值，那么等式一定保持相等。</p>
<p>具体来讲，就是 prover 选择一个随机值 <em>δ</em> ，并用它对证明中的值进行求幂</p>
<p>$(g^{p(s)})^δ$ , $(g^{h(s)})^δ$ , $(g^{αp(s)})^δ$ </p>
<p>然后提供验证内容给 verifier：</p>
<p>$(g^p)^δ = ((g^h)^δ)^{t(s)}$</p>
<p>$((g^p)^δ)^α = (g^{p'})^δ$</p>
<p>再合并一下我们就可以看到校验的等式依然成立：</p>
<p>$g^{δ \cdot p} = g^{δ \cdot t(s)h}$</p>
<p>$g^{δ \cdot αp} = g^{δ \cdot p'}$</p>
<p>注意零知识是如何轻而易举地融入到这个结构中去的，这通常也被称为&quot;无成本的&quot;零知识。</p>
<blockquote>
<p>even@安比实验室: 借助这个”无成本的”技巧，就可以轻松实现零知了。但是这里实现零知识的方法和实际中的Pinocchio协议，还有Groth16 方案略有不同。实际方案中是用乘法乘以 $g^{δ\cdot t(s)}$。</p>
</blockquote>
<h2 id="非交互式"><a class="header" href="#非交互式">非交互式</a></h2>
<p>到现在为止，我们已经讲完了一个交互式的零知识方案。但为什么我们还需要有非交互式呢？因为交互式证明只对原始的 verifier 有效，其他任何人（其他的 verifier）都不能够信任这个证明，因为：</p>
<ul>
<li>verifier 可以和 prover 串通，告诉他密码参数 <em>s</em>, <em>α</em>，有了这些参数 prover 就可以伪造证明，就像前面  <strong>remark 3.1</strong> 提到的那样。</li>
<li>verifier 也可以使用同样的方法自己伪造证明。</li>
<li>verifier 必须保存 <em>α</em> and <em>t</em>(<em>s</em>) 直到所有相关证明被验证完毕，这就带来了一个可能造成秘密参数泄漏的额外攻击面。</li>
</ul>
<p>因而 prover 就需要分别和每个 verifier 做交互来证明一个陈述（就是例子中指的多项式的知识）。</p>
<p>尽管交互式证明也有它的用处，例如一个 prover 只想让一个特定的 verifier （称为目标 verifier，更多的信息参见 [<a href="https://medium.com/@imolfar/why-and-how-zk-snark-works-3-non-interactivity-distributed-setup-c0310c0e5d1c#4b56">JSI96</a>] ）确信，就不能再重复利用同一个证明去向别人证明这个声明了，但是当一个 prover 想让众多的参与者同时或者永久地确信的话，这种方法就很低效了。 prover 需要保持一直在线并且对每一个 verifier 执行相同的计算。</p>
<p>因而，<strong>我们就需要一个可以被重复使用，公开，可信，又不会被滥用的秘密参数</strong>。</p>
<p>我们先来思考一下如何在构造出秘密值 (<em>t</em>(<em>s</em>)<em>,α</em>) 构造之后保证它的安全性。我们可以对其进行加密，方式与 verifier 在发送加密值给 prover 之前对 <em>s</em> 的幂使用的加密方式一致。但是 <strong>remark 3.2</strong> 中提到，我们使用的同态加密并不支持两个秘密值相乘，这一点对 <em>t</em>(<em>s</em>) 和 <em>h</em> 的加密值相乘以及 <em>p</em> 和 <em>α</em> 的加密值相乘的验证都很重要。这个问题适合用Pairing配对操作来解决。</p>
<blockquote>
<p>even@安比实验室:这里非交互的证明协议将对参数加密，但引入了两个问题：</p>
<p>1）同态加密无法对两个加密值做乘法，那如何验证加密后的参数呢？</p>
<p>2）加密值一旦泄露，协议的信任关系将无法保证，如何确保参数的安全性？</p>
</blockquote>
<h3 id="加密值的相乘"><a class="header" href="#加密值的相乘">加密值的相乘</a></h3>
<p>配对操作（双线性映射）是一个数学结构，表示为函数  <em>e(g,g)</em>，它给定一个数据集中的两个加密的输入（即 <em>g<sup>a</sup>, g<sup>b</sup></em> ），可以将他们确定性地映射到另一组不同的输出数据集上的它们的乘积，即 <em>e(g<sup>a</sup>, g<sup>b</sup>) = e(g, g)<sup>ab</sup></em>：</p>
<p><img src="./img/2/1*0Qnz6c35UV1bv7uk620qrw.png" alt="" /></p>
<p>因为源数据集和输出数据集（通常被称为一个 group）是不同的，所以一个配对的结果不能用做其他配对计算的输入。我们可以将输出集（也称为“目标集”）视为“不同的宇宙”。因而我们不能用另一个加密值乘以结果，而且配对这个名称本身也表明了，我们一次只能将两个加密值相乘。</p>
<blockquote>
<p>even@安比实验室: 换句话说，配对只支持 x * y 这种两个值的乘法，但不支持三个或以上的值相乘，比如不支持 x * y * z。</p>
</blockquote>
<p>在某种意义上，这个类似于一个哈希函数，他将所有可能的输入值映射到可能的输出值的集合中的一个元素上，通常情况下这个过程是不可逆的。</p>
<p><em>注意：乍一眼看过去，这个限制可能会阻碍相关功能的实现，但在 zk-SNARK 中这反而是保证安全模式的最重要性质，参见 <strong>remark 3.3</strong>。</em></p>
<p>配对函数 <em>e</em>(<em>g</em>,<em>g</em>) 可以初步（严格来说是不对的）地类比成“交换”每一个输出的基数和指数的操作，使得基数 <em>g</em> 在交换过程中被修改成了指数的方式，即 <em>g<sup>a</sup> → a<sup>g</sup></em> 。&quot;被转换&quot;的两个输入一起被修改了，这样原始值 <em>a</em> 和 <em>b</em> 就在同一个指数下相乘了，即：</p>
<p>$e(g^a,g^b) =a^g \cdot b^g =(ab)^g$</p>
<p>因而因为基数在“转换”中被修改了，所以在另一个配对中不能再使用这个结果 (<em>ab</em>)<strong>ᵍ</strong> （即：<em>e</em>((<em>ab</em>)<em>ᵍ</em>, g<em>ᵈ</em>)）构造出想要的加密乘积 <em>abd</em> 了。配对的核心性质可以表示成下面的等式：</p>
<p>$e(g^a,g^b) =r(g^b,g^a)=e(g^{ab},g^1)=e(g^1,g^{ab}) =e(g^1,g^a)^b =e(g^1,g^1)^{ab}$</p>
<p>严格来讲一个配对的结果是在目标集的一个不同生成元 <em>g</em> 下对原始值乘积的加密，即 <em>e</em>(<em>g</em>ᵃ, <em>g</em> <em>ᵇ</em>) = <em>gᵃᵇ</em>。因而它具备同态加密的性质，也就是说我们可以把乘法配对的加密乘积放到一起：</p>
<p>$e(g^a,g^b) \cdot e(g^c, g^d) = g^{ab} \cdot g^{cd} =g^{ab+cd} =r(g,g)^{ab+cd}$</p>
<blockquote>
<p>注意：配对操作是通过改变椭圆曲线来实现这些性质的，现在我们用的符号  gⁿ 就代表曲线上一个由生成元自相加了 n  次的点，而不是我们前面用到的乘法群生成元。</p>
</blockquote>
<p>[<a href="https://medium.com/@imolfar/why-and-how-zk-snark-works-3-non-interactivity-distributed-setup-c0310c0e5d1c#0ea5">DBS04</a>] 这个综述提供了学习配对的出发点。</p>
<h3 id="可信任参与方的-setup"><a class="header" href="#可信任参与方的-setup">可信任参与方的 Setup</a></h3>
<p>有了配对，我们现在就准备去设置安全公开且可复用的参数了。假定一下我们让一个诚实的参与方来生成秘密值 <em>s</em> 和 <em>α</em>。只有  <em>α</em> 和所有必要的 <em>s</em> 的幂及其对应的  <em>α</em>-变换被加密了，那么原始数据就必须要被删除（ i 为 0，1,…,d ）：</p>
<p>$g^α，g^{s^i}，g^{αs^i}$</p>
<p>这些参数通常被称为 <em>common reference string</em> 或者 CRS。CRS 生成后，任何的 prover 和任何的 verifier 都可以使用它来构造非交互式的零知识证明协议。CRS 的优化版本将包含目标多项式的加密值  $g^{t(s)}$，尽管这个值并不重要。</p>
<p>把 CRS 分成两组（ i 为 0，1,…,d ）：</p>
<ul>
<li><em>proving  key</em>（也被称为 <em>evaluation key</em>）：$(g^{s^i},g^{αs^i})$</li>
<li><em>verification key</em>：$(g^{t(s)},g^α)$</li>
</ul>
<p>只要能够乘以加密值，verifier 就可以在协议的最后一步验证多项式了：</p>
<ul>
<li>
<p>有了verification key，verifier 就可以处理从 prover 那里得到的加密多项式的值 $g^p$，$g^h$，$g^{p'}$：</p>
<ul>
<li>
<p>在加密空间中校验  <em>p = t·h</em>：</p>
<p>$e(g^p,g^1) = e(g^t,g^h)$</p>
</li>
<li>
<p>校验多项式的限制：</p>
<p>$e(g^p,g^α) = e(g^{p'},g)$</p>
</li>
</ul>
</li>
</ul>
<h3 id="信任任意一个参与者"><a class="header" href="#信任任意一个参与者">信任任意一个参与者</a></h3>
<p>尽管受信任设置很有效率，但众多 CRS 用户也必须要相信生成者确实删除了 α 和 s ，这一点没有办法证明（<em>proof of ignorance</em> 是一个正在积极研究的领域 [<a href="https://medium.com/@imolfar/why-and-how-zk-snark-works-3-non-interactivity-distributed-setup-c0310c0e5d1c#2823">DK18</a>]），所以这种方法依然是无效的。因而很有必要去最小化或者消除这种信任。否则一个不诚实的参与方就可以构造假证明而不被发现。</p>
<p>一种解决办法就是由多个参与方使用前面小节中介绍的数学工具来生成一个组合式CRS，这样这些参与方就都不知道「秘密」了。下面是一个实现方案，我们假设有三个参与者 Alice，Bob 和 Carol ，对应为 A，B 和 C，其中 i为 1, 2, …, d：</p>
<ul>
<li>
<p>Alice 选择随机数 $s_A$ 和 $α_A$，然后公开她的 CRS：</p>
<p>$(g^{s^i_A}，g^{α_A}，g^{α_As^i_A})$</p>
</li>
<li>
<p>Bob 选择他的随机数 $s_B$ 和 $α_B$，然后通过同态乘法结合 Alice 的 CRS：</p>
<p>$((g^{s_A^i})^{s_B^i},(g^{α_{A}})^{α_B},(g^{α_As_A^i})^{α_Bs_B^i}) = (g^{(s_As_B)^i},g^{α_Aα_B},g^{α_Aα_B(s_As_B)^i})$</p>
<p>然后公开两方 Alice-Bob 的 CRS 结果：</p>
<p>$(g^{s^i_{AB}},g^{α_{AB}},g^{α_{AB}s^i_{AB}})$</p>
</li>
<li>
<p>Carol 用她的随机数  $s_C$ 和 $α_C$ 做同样的事：</p>
<p>$((g^{s^i_{AB}})^{s^i_C},(g^{α_{AB}})^{α_C},(g^{α_{AB}s^i_{AB}})^{α_Cs^i_C}) = (g^{(s_As_Bs_C)^i},g^{α_Aα_Bα_C},g^{α_Aα_Bα_C(s_As_Bs_C)^i})$</p>
<p>然后公开 Alice-Bob-Carol 的 CRS:</p>
<p>$(g^{s^i_{ABC}},g^{α_{ABC}},g^{α_{ABC}s^i_{ABC}})$ </p>
</li>
</ul>
<p>这个协议最后我们就获得了一个混合的 <em>sⁱ</em> 和 <em>α</em>：</p>
<p>$s^i=s^i_As^i_Bs^i_C, α=α_Aα_Bα_C$</p>
<p>除非他们串谋，否则参与者们互相之间并不知道其他人的秘密参数。实际上，一个参与者必须要和其它所有的参与者串谋才能得到 <em>s</em> 和 <em>α</em>，这样在所有的参与者中只要有一个是诚实的，就没有办法伪造证明。</p>
<blockquote>
<p>注意：这个过程可以被尽可能多的参与者重复完成</p>
</blockquote>
<p>有一个问题是如何验证参与者在生成 CRS 时用的随机数值是一致的，因为攻击者可以生成多个不同的随机数 <em>s</em>₁*, s<em>₂</em>, …* 和 <em>α</em>₁*, α<em>₂</em>, …*,，然后代入这些不同的随机数去执行 <em>s</em> 的不同次幂计算（或提供随机数作为一个 CRS 的扩充），从而使 CRS 无效或者不可用。</p>
<p>庆幸的是，因为我们可以使用配对来乘以加密值，所以我们就可以从第一个参数开始逐一执行一致性校验，并且确保了每个参数都源于前一个。</p>
<ul>
<li>
<p>我们用 s 的 1 次幂作为标准来校验每一个其它次幂的值与之是否保持一致</p>
<p>$e(g^{s^i},g) = e(g^{s^1},g^{s^{i-1}})|_{i\in{2,……,d}}$</p>
<p>例如：</p>
<ul>
<li>2 次幂：$e(g^{s^2},g) = e(g^{s^1},g^{s^1}) =&gt; e(g,g)^{s^2} = e(g,g)^{s^{1+1}}$</li>
<li>3 次幂：$e(g^{s^3},g) = e(g^{s^1},g^{s^2}) =&gt; e(g,g)^{s^3} = e(g,g)^{s^{1+2}}$，等</li>
</ul>
</li>
<li>
<p>我们现在再验证一下前面步骤中 α-变换后的值是否正确：</p>
<p>$e(g^{s^i},g^α) = e(g^{αs^i},g)|_{i\in[d]}$</p>
<p>例如：</p>
<ul>
<li>3 次幂：$e(g^{s^3},g^α) = e(g^{αs^3,g}) =&gt; e(g,g)^{s^3 \cdot α} = e(g,g)^{αs^3}$，等。</li>
</ul>
</li>
</ul>
<p>这里 $i \in {2,……,d}$ 是“<em>i</em> 值分别为 2，3，…，d” 的缩写， [<em>d</em>] 是 <em>1</em>, <em>2</em>, …, <em>d</em> 这个范围的缩写形式，在后面的章节这种表示方式更为常见。</p>
<p>当我们在验证每一个参与者秘密参数的一致性时，要注意参与者生成 CRS 的过程并没有强制后一个参与者（就是我们例子中的 Bob 和 Carol）都要使用前面已经公开的 CRS。因而如果一个攻击者是链上的最后一个参与者，他可以像链上的第一个参与者一样忽略前面的 CRS 随便构造一个有效的 CRS，这样他就变成了唯一一个知道秘密 <em>s</em> 和 <em>α</em> 的人。</p>
<p>为了解决这个问题，我们可以额外再要求除了第一个以外的每一个参与者去加密然后公开他的参数。例如，Bob 同样公开了：</p>
<p>$(g^{s^i_B},g^{α_B},g^{α_Bs^i_B})|_{i\in[d]}$</p>
<p>这就可以去验证 Bob 的 CRS 是乘以了 Alice 的参数后正常获得的，这里 i 为 <em>1</em>, <em>2</em>,…, <em>d</em>。</p>
<ul>
<li>$e(g^{s^i_{AB}},g) = e(g^{s^i_A},g^{s^i_B})$</li>
<li>$e(g^{α_{AB}},g) = e(g^{α_A},g^{a_B})$</li>
<li>$e(g^{α_{AB}s^i_{AB}},g) = e(g^{α_As^i_A},g^{α_Bs^i_B})$</li>
</ul>
<p>同样的，Carol 也必须证明她的 CRS 是乘以了 Alice-Bob 的 CRS 后正常获得的。</p>
<p>这是一个健壮的 CRS 设置模式，它并不完全依赖于单个参与者。事实上，即使其它所有的参与者都串谋了，只要有一个参与者是诚实的，他能够删除并且永远不共享它的秘密参数，这个 CRS 就是有效的。所以在设置 CRS （有时候被称为仪式 [<a href="https://medium.com/@imolfar/why-and-how-zk-snark-works-3-non-interactivity-distributed-setup-c0310c0e5d1c#191c">Wil16</a>]）的时候有越多不相关的参与者参与，伪造证明的可能性就越低。当有相互竞争的参与方参与的时候，就几乎不可能伪造证明了。这种模式能够包容其他一些怀疑这种 setup 可识别性的不受信方因为校验步骤确保了他们不会破坏（这里也包括很弱的 <em>α</em> 和 <em>s</em> 的使用）最终的 CRS。</p>
<p>&gt;even@安比实验室: 现在有一些zkSNARK方案支持可升级的 CRS，任何怀疑CRS的参与方都可以对CRS 进行更新。此外还有一些 zkSNARK方案支持 Universal CRS，用不着对每一个电路进行受信任设置，而是只需要全局完成一次即可。除此之外，大量无需 Trusted Setup 的方案正在被充分研究。</p>
<p>##多项式的 SNARK</p>
<p>我们现在准备来合并这个逐步演化出来的 <em>zk-SNARKOP</em> 协议。为简洁起见，我们将使用大括号来表示由旁边的下标填充的一组元素，例如：</p>
<p>${s^i}_{i\in[d]}$</p>
<p>表示一组数 s<sup>1</sup>，s<sup>2</sup>， …， <em>s<sup>d</sup></em> 。我们已经明确目标多项式 <em>t(x)</em> 和 prover 的多项式阶数 <em>d</em>：</p>
<ul>
<li>Setup
<ul>
<li>挑选随机值 <em>s</em>，<em>α</em></li>
<li>计算加密值 $g^α$ 和 ${g^{s^i}}<em>{i\in[d]}$，${g^{αs^i}}</em>{i\in{0,…,d}}$</li>
<li>生成 <em>proving key</em>：$({g^{s^i}}<em>{i\in[d]},{g^{αs^i}}</em>{i\in{0,…,d}})$</li>
<li>生成 <em>verification key</em>: $(g^α，g^{t(s)})$</li>
</ul>
</li>
<li>Proving
<ul>
<li>分配系数 ${c_i}_{i\in{0,…,d}}$ (即知识)得 $p(x) = c_dx^d +…+ c_1x^1 + c_0x^0$</li>
<li>求多项式 $h(x) = p(x)/t(x)$</li>
<li>代入 ${g^{s^i}}_{i\in[d]}$ 计算多项式 $g^{p(s)}$ 和 $g^{h(s)}$ 的值</li>
<li>代入 ${g^{αs^i}}_{i\in[d]}$ 计算变换多项式 $g^{αp(s)}$ 的值</li>
<li>选择随机数 <em>δ</em></li>
<li>构造随机化的证明 $π = (g^{δp(s)},g^{δh(s)},g^{δαp(s)})$</li>
</ul>
</li>
<li>verification
<ul>
<li>映射证明 <em>π</em> 为 $(g^p,g^h,g^{p'})$</li>
<li>验证多项式约束：$e(g^{p'},g) = e(g^p,g^α)$</li>
<li>验证多项式系数：$e(g^p,g) = e(g^{t(s)},g^h)$</li>
</ul>
</li>
</ul>
<p><strong>Remark 3.3</strong> 如果 pairing 的结果有可能在其它类似的乘法协议中被复用，那么这里就完全没有安全性可言了，因为这样的话 prover 就可以构造</p>
<p>$g^{p'} = e(g^p,g^α)$</p>
<p>这样也可以通过&quot;多项式约束&quot;的检查：</p>
<p>$e(e(g^p,g^α)，g) = e(g^p,g^α)$</p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>我们用 zk-SNARK 协议来解决多项式问题的知识，不过这是一个有局限的例子。因为大家可以说 prover 只要用另外一个有界的多项式去乘以 t(x) 就可以很容易得构造出一个能够通过测试的多项式  <em>p</em>(<em>x</em>) ，并且这种结构也是有效的。</p>
<p>verifier <em>知道</em> prover 有一个有效的多项式，但是并不知道是哪一个。我们可以利用多项式的其他性质添加额外的证明，如**:**被多个多项式整除，是某个多项式的平方。虽然可能会有一个服务能够接受，存储和奖励所有经过证明的多项式，或者有一个需求，加密计算某种形式的未知多项式。然而若有通用方案就可以支撑无数的应用。</p>
<blockquote>
<p>even@安比实验室:总结一下这篇文章中一步一步解决了下面的几个问题：</p>
<p>保证 prover 的证明是按照规则正确构造的 ——&gt; KEA</p>
<p>保证知识的零知性 ——&gt; “无成本的”δ 变换</p>
<p>可复用证明 ——&gt; 非交互式</p>
<p>非交互中如何设置安全公开且可复用的参数 ——&gt; 参数加密，verifier 借助密码配对进行验证</p>
<p>保证参数的生成者不泄密 ——&gt; 多方的 Setup</p>
<p>至此，一个用来证明多项式知识的完整的 zk-SNARK 协议就构造出来了，不过现在的协议在通用性上依然还有很多限制，后面的文章将继续介绍如何构造通用的 zk-SNARK。</p>
</blockquote>
<p><strong>参考文献</strong></p>
<p>[Dam91] — Ivan Damgård. “Towards practical public key systems secure against chosen ciphertext attacks”. In: <em>Annual International Cryptology Conference</em>. Springer. 1991, pp. 445–456.</p>
<p>[Gro10] — Jens Groth. “Short pairing-based non-interactive zero-knowledge arguments”. In: <em>International Conference on the Theory and Application of Cryptology and</em> <em>Information Security</em>. Springer. 2010, pp. 321–340.</p>
<p>[JSI96] — Markus Jakobsson, Kazue Sako, and Russell Impagliazzo. “Designated verifier proofs and their applications”. In: <em>International Conference on the Theory and Applications</em> <em>of Cryptographic Techniques</em>. Springer. 1996, pp. 143–154.</p>
<p>[DBS04] — Ratna Dutta, Rana Barua, and Palash Sarkar. <em>Pairing-Based Cryptographic Protocols: A Survey</em>. Cryptology ePrint Archive, Report 2004/064. https://eprint.iacr.org/2004/064. 2004.</p>
<p>[DK18] — Apoorvaa Deshpande and Yael Kalai. <em>Proofs of Ignorance and Applications</em> <em>to 2-Message Witness Hiding</em>. Cryptology ePrint Archive, Report 2018/896. https://eprint.iacr.org/2018/896. 2018.</p>
<p>[Wil16] — Zooko Wilcox. <em>The Design of the Ceremony</em>. 2016. url: https://z.cash/blog/the-design-of-the-ceremony/</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch01.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch03.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch01.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch03.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
