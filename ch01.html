<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>多项式的性质与证明 - zk-SNARK 为什么以及如何工作</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="《zk-SNARK 为什么以及如何工作（Why and How zk-SNARK Works）》简体中文版">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded affix "><a href="abstract.html">摘要</a></li><li class="chapter-item expanded "><a href="ch01.html" class="active"><strong aria-hidden="true">1.</strong> 多项式的性质与证明</a></li><li class="chapter-item expanded "><a href="ch02.html"><strong aria-hidden="true">2.</strong> 多项式的非交互式零知识证明</a></li><li class="chapter-item expanded "><a href="ch03.html"><strong aria-hidden="true">3.</strong> 从程序到多项式的构造</a></li><li class="chapter-item expanded "><a href="ch04.html"><strong aria-hidden="true">4.</strong> 多项式的约束</a></li><li class="chapter-item expanded "><a href="ch05.html"><strong aria-hidden="true">5.</strong> Pinocchio 协议</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">zk-SNARK 为什么以及如何工作</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/zyw271828/wahzw-zh-cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="从零开始学习-zk-snark一多项式的性质与证明"><a class="header" href="#从零开始学习-zk-snark一多项式的性质与证明">从零开始学习 zk-SNARK（一）——多项式的性质与证明</a></h1>
<h2 id="序言和介绍"><a class="header" href="#序言和介绍">序言和介绍</a></h2>
<p>尽管最初计划写短一些，但现在已经写了几十页了，不过这篇文章读起来几乎不需要什么预备知识，并且你也可以随意跳过熟悉的部分。如果你不熟悉文中使用的某些数学符号也不需要担心，文中将会对这些符号逐个进行介绍。</p>
<p><em>Zero-knowledge</em> <em>succinct non-interactive arguments of knowledge</em> (<em>zk-SNARK</em>) 确实是一种非常精妙的方法，它可以在不揭示任何信息的前提下证明某个论断为真。但首要问题是，它为什么有用？</p>
<p>其实零知识证明在无数的应用中都具备优势，包括：</p>
<p>1）证明关于隐私数据的声明：</p>
<ul>
<li>
<p>一个人 <em>A</em> 的银行账户金额多于 X</p>
</li>
<li>
<p>去年，一家银行未与实体 Y 进行交易</p>
</li>
<li>
<p>在不暴露全部 DNA 数据的前提下匹配 DNA</p>
</li>
<li>
<p>一个人的信用评分高于 Z</p>
<p>2）匿名认证：</p>
</li>
<li>
<p>在不揭露身份的情况下（比如登录密码），证明请求者 R 有权访问网站的受限区域</p>
</li>
<li>
<p>证明一个人来自一组被允许的国家/地区列表中的某个国家/地区，但不暴露具体是哪个</p>
</li>
<li>
<p>证明一个人持有地铁月票，而不透露卡号</p>
</li>
</ul>
<p>3）匿名支付：</p>
<ul>
<li>付款完全脱离任何一种身份</li>
<li>纳税而不透露收入</li>
</ul>
<p>4）外包计算</p>
<ul>
<li>将昂贵的计算外包，并在不重新执行的情况下验证结果是否正确；它打开了一种零信任计算的类别</li>
<li>改进区块链模型，从所有节点做同样的计算，到只需一方计算然后其它节点进行验证</li>
</ul>
<p>和「零知识证明」这个伟大的名词一样，其背后的方法可以说是数学和密码学的奇迹。自1985 年，零知识证明这个概念在 “交互式证明系统的知识复杂性”[GMR85]一文中被引入，还有随后的非交互式零知识证明[[BFM88]以来（在区块链环境中尤其重要），至今已经进入到第四个十年的研究。</p>
<p>在任意的「零知识证明」系统中，都有一个 <em>prover</em> 在不泄漏任何额外信息的前提下要让 <em>verifier</em> 确信某些陈述（Statement）是正确的。例如 <em>verifier</em> 仅能知道 <em>prover</em> 的银行账户金额超过 <em>X</em>（也就是不披露实际金额）。协议应当满足下面三个性质：</p>
<ul>
<li>完整性 —— 只要「陈述」是正确的，<em>prover</em> 就可以让 <em>verifier</em> 确信</li>
<li>可靠性 —— 如果「陈述」是错误的，那么作弊的 <em>prover</em> 就没有办法让 <em>verifier</em> 相信</li>
<li>零知识 —— 协议的交互仅仅揭露「陈述」是否正确而不泄漏任何其它的信息</li>
</ul>
<p>zk-SNARK 这个术语本身是在 [Bit+11] 中引入的，它在[Gro10]的基础上，又遵循了匹诺曹协议[Gen+12; Par+13] 使其能够适用于通用的计算。</p>
<h2 id="证明的媒介"><a class="header" href="#证明的媒介">证明的媒介</a></h2>
<p>这里我们先不要去管零知识，非交互性，其形式和适用性这些概念，就从尝试证明一些简单的东西开始。</p>
<p>想象一下我们有一个长度为10 的位数组，现在要向 verifier（例如，程序）证明这样一个陈述：所有的位都被设置成了 1。</p>
<p><img src="img/1_qYcj1rieth4Rkaphwx3tGw.png" alt="" /></p>
<p>verifier 一次只能检查（即，读）一位。为了验证这个陈述，我们以某种任意的顺序读取元素并检查其是否确实等于 1 。如果第一次抽样检查的结果是 1，就设置「陈述」的可信度为 ⅒= 10％，否则，如果等于 0，就说明「陈述」是错误的。验证者继续进行下一轮验证，直到获得足够的可信度为止。假如在一些场景下要信任 prover 需要至少 50% 的可信度，那就意味着必须执行 5 次校验。但假如在其它一些场景下需要 95% 的可信度，就需要检查所有的元素。很明显这个证明协议的缺点是必须要根据元素的数量进行检查，如果我们处理数百万个元素的数组，这么做是不现实的。</p>
<p>现在我们来看一下由数学方程式表示的多项式，它可以被画成坐标系上的一条曲线：</p>
<p><img src="img/1_-icO0q-Mu7AcFFMmCoOvfQ.png" alt="" /></p>
<p>上面的曲线对应多项式: <em>f(x) = x³ – 6x² +11x– 6</em>。多项式的阶数取决于 <em>x</em> 的最大指数，当前多项式的阶数是 3。</p>
<p>多项式有一个非常好的特性，就是如果我们有两个阶为 d 的不相等多项式，他们相交的点数不会超过 d。例如，稍微修改一下原来的多项式为 <em>x³ – 6x² + 10x– 5</em> （注：请注意这里只修改了多项式的最后一个系数，6改成了5）并在图上用绿色标出：</p>
<p><img src="img/1_7JGXnnMDoEr4Rbn7-WOSQw.png" alt="" /></p>
<p>这一点微小的修改就产生了变化很大的曲线。事实上，我们不可能找到两条不同的曲线，他们会在某段区域内重合（他们只会相交于一些点）。</p>
<p>这是从找多项式共同点方法中得出的性质。如果要查找两个多项式的交点，就要先令它们相等。例如，要找到多项式与 <em>x</em> 轴的交点（即 <em>f(x) = 0</em>），我们就要令 <em>x³ – 6x² + 11x – 6 = 0</em>，等式的解就是共同点：<em>x= 1</em> ，<em>x= 2</em> 和 <em>x= 3</em>。在上面图中也可以很清晰得看出这些解，也就是图上蓝色曲线和 <em>x</em> 轴相交的地方。</p>
<p>同样，我们也可以令上文中原始的多项式和修改后的多项式相等，找到它们的交点。</p>
<p><em>x³ – 6x² + 11x – 6 =x³ – 6x² + 10x – 5</em></p>
<p><em>x-1=0</em></p>
<p>多项式化简后的结果阶数为 1，它有一个很明显的解 <em>x</em> = 1。因而这两个多项式有一个交点。</p>
<p><img src="img/1_5tGItKaiCxwLAjYJaBRffg.png" alt="" /></p>
<p>任意一个由阶数为 <em>d</em> 的多项式组成的等式，最后都会被化简为另外一个阶数至多为 <em>d</em> 的多项式，这是因为等式中没有能够用来构造更高阶数的乘法。例如：<em>5x³ + 7x² – x + 2 = 3x³ – x² + 2x– 5</em>，简化为 <em>2x³ + 8x² – 3x + 7 = 0</em>。另外代数的基本原理也告诉我们，对于一个阶数为 <em>d</em> 的多项式至多有 <em>d</em> 个解（以下部分将对此进行详细介绍），因而也就至多有<em>d</em> 个共同点。</p>
<p>所以我们可以得出结论，任何多项式在任意点的计算结果（更多关于多项式求值参考：[Pik13]）都可以看做是其唯一身份的表示。我们来计算一下当 <em>x</em> = 10 时，示例多项式的结果。</p>
<p><em>x³ – 6x² +11x - 6 = 504</em></p>
<p><em>x³ – 6x² +10x - 5 = 495</em></p>
<p>事实上，在 <em>x</em> 可以选择的所有值中，至多只有三个值能够使这些多项式相等，其它的值都是不相等的。</p>
<p>这也是为什么如果一个 prover 声称他知道一些 verifier 也知道的多项式（无论多项式的阶数有多大）时，他们就可以按照一个简单的协议去验证：</p>
<ul>
<li>verifier 选择一个随机值 x 并在本地计算多项式结果</li>
<li>verifier 将 x 值给到 prover，并让他计算相关的多项式结果</li>
<li>prover 代入 x 到多项式计算并将结果给到 verifier</li>
<li>verifier 检查本地的计算结果和 prover 的计算结果是否相等，如果相等那就说明 prover 的陈述具有较高的可信度</li>
</ul>
<p>例如，我们把 x 的取值范围定在 1 到 10⁷⁷,  那么计算结果不同的点的数量，就有 <em>10⁷⁷ – d</em> 个。因而 <em>x</em> 偶然“撞到”这 d 个结果相同的点中任意一个的概率就等于（可以认为是几乎不可能）：$\frac{d}{10^{77}}$</p>
<blockquote>
<p>@Maksym（作者）：与低效的位检查协议相比，新的协议只需要一轮验证就可以让声明具有非常高的可信度（假设 <em>d</em> 远小于 <em>x</em> 取值范围的上限，就几乎是 100%了）</p>
</blockquote>
<p>这也是为什么即使可能存在其他的证明媒介，<strong>多项式依然是 zk-SNARK 相对核心的部分</strong>。</p>
<blockquote>
<p>even@安比实验室: 这一节告诉了我们多项式的一个重要性质：我们不可能找到共享连续段的两条不相等曲线，也就是任何多项式在任意点的计算结果都可以看做是其唯一身份的表示。也就是说只要能证明多项式上的某个随机点就可以证明这个多项式（只有在知道了多项式，才能算出这个点对于的值），这个性质是我们下面所有证明的核心。</p>
<p>这就是 Schwatz-Zippel 定理，它可以扩展到多变量多项式，即在一个多维空间内形成一个曲面。这个定理会在多个零知识证明方案的证明中反复出现。</p>
</blockquote>
<h2 id="证明多项式的知识"><a class="header" href="#证明多项式的知识">证明多项式的知识</a></h2>
<p>我们的讨论从证明多项式的知识开始，再将证明协议逐步转换成一种通用的方法，在这个过程中我们也将发现多项式的很多其它性质。</p>
<p>但是到目前为止，我们的协议还只是一个很弱的证明，因为协议中并没有采取任何措施去保证参与方必须按照协议的规则生成证明，所以参与方只能互相信任。例如，prover 并不需要知道多项式，也可能通过其它方式得到正确的答案。而且，如果 verifier 要验证的多项式的解的取值范围不够大，比如我们前文说的 10，那个就可以去猜一个数字，猜对答案的概率是不可忽略不计的。因而我们必须要解决协议中的这个缺陷，在解决问题之前首先来想一下，<strong>知道多项式意味着什么呢？</strong></p>
<p>多项式可以用下面的形式来表示（其中 <em>n</em> 指的是多项式的阶）：</p>
<p>$$
c_{n} x^{n}+\ldots \ldots+c_{1} x^{1}+c_{0} x^{0}
$$</p>
<p>如果一个人说他或她知道一个一阶多项式（即：$c_{1} x^{1} + c_{0} = 0$），那么这就意味着他或她确实<em>知道</em> 系数 $c_{0}$, $c_{1}$ 的值。这个系数可以是包括 0 在内的任意值。</p>
<p>假设证明者声称他知道一个包含 <em>x=1</em> 和 <em>x=2</em> 两个解的三阶多项式。满足此条件的一个有效的多项式就是 <em>x3 – 3x2+ 2x= 0</em>。因为<em>x= 1: 1 – 3 + 2 = 0</em>，<em>x= 2: 8 – 12 + 4 = 0</em>。</p>
<p>我们先来仔细得研究一下这个答案的结构。</p>
<blockquote>
<p>even@安比实验室: 这一节告诉了我们多项式的一个本质——多项式的「知识」就是多项式的系数。所谓「知道」多项式就是指「知道」多项式的系数。</p>
</blockquote>
<h2 id="因式分解"><a class="header" href="#因式分解">因式分解</a></h2>
<p>代数的基本定理表明了任意的一个多项式只要它有解，就可以将它分解成线性多项式（即，一个阶数为 1 的多项式代表一条线），因此，我们可以把任意有效的多项式看成是其因式的乘积：</p>
<p>$(x-a_0)(x-a_1)…(x-a_n) = 0$</p>
<p>也就是说如果任意一个因式为 0，那么整个等式都为 0，也就是说式子中所有的 $a_s$ 就是多项式的所有解。</p>
<p>$x^3 -3x^2 + 2x = (x-0)(x-1)(x-2)$</p>
<p>所以这个多项式的解（<em>x</em> 的值）就是：0，1，2，在任何形式下多项式的解都可以很轻松的被验证，只不过因式的形式可以让我们一眼就看出这些解（也称为根）。</p>
<p>我们再回到前面的问题， prover 宣称他知道一个阶数为 3，其中两个根分别为 1 和 2 的多项式，也就是说这个多项式的形式为：</p>
<p>$(x-1)(x-2) \cdot …$</p>
<p>换句话说 (<em>x</em>–<em>1</em>) 和 (<em>x</em> –<em>2</em>) 是问题中多项式的两个因式。因而如果 prover 想要在不揭示多项式的前提下证明他的多项式确实有这两个根，那么他就需要去证明他的多项式 <em>p(x)</em> 是 <em>t</em>(<em>x</em>) = (<em>x</em>- 1)(<em>x</em>- 2) （也称为目标多项式）和一些任意多项式 <em>h(x)</em> （也就是我们的例子里面的 <em>x - 0</em>）的乘积，即：</p>
<p><em>p(x) = t(x) · h(x)</em></p>
<p>换句话说，存在一些多项式 <em>h(x)</em> 能够使得 <em>t(x)</em> 与之相乘后等于 <em>p(x)</em>，由此得出， <em>p(x)</em> 中包含 <em>t</em>(<em>x</em>)，所以 <em>p(x)</em> 的根中也包含 <em>t</em>(<em>x</em>) 的所有根，这也就是我们要证明的东西。</p>
<p>自然算出 <em>h(x)</em> 的方式就是直接相除：</p>
<p>$h(x) = \frac{p(x)}{t(x)}$</p>
<p>如果一个 prover 不能找到这样一个 <em>h(x)</em> 也就意味着 <em>p(x)</em> 中不包含因式 <em>t</em>(<em>x</em>)，那么多项式相除就会有余数。例如我们用 <em>p(x) = x³ – 3x² + 2x</em> 除以 <em>t(x) = (x – 1)(x – 2) = x² – 3x+ 2</em></p>
<p><img src="img/1_iT3kRk3C-DJdvQgi1b2uOA.png" alt="" /></p>
<p><em>注意：左边的式子是分母，右上角的是计算结果。底部是余数（多项式相除的解释及示例可以看这里 [Pik14] ）。</em></p>
<p>我们算出结果 <em>h(x) = x</em>，没有余数。</p>
<p><em>注意：为了简化起见，后面我们会用多项式的字母变量来代替计算结果值，例如：p = p(r)。</em></p>
<blockquote>
<p>even@安比实验室: 多项式可以被因式分解成它的根的因式的乘积。这个性质就意味着，如果一个多项式有某些解，那么它被因式分解后的式子中一定包含这些解的因式。</p>
<p>有了这个性质，我们就可以愉快地去做一些证明啦。</p>
</blockquote>
<p>利用<strong>多项式一致性检查协议</strong>我们就可以比较多项式 <em>p(x)</em> 和 <em>t(x) ⋅ h(x)</em>：</p>
<ul>
<li>verifier 挑选一个随机值 <em>r</em>, 计算 <em>t</em> = <em>t(r)</em> (即，求值) ，然后将 <em>r</em> 发送给 prover。</li>
<li>prover 计算 <em>h</em>(<em>x</em>) =<em>p</em>(<em>x</em>) / <em>t</em>(<em>x</em>) ，并对 <em>p(r)</em> 和 <em>h(r)</em> 进行求值，将计算结果 <em>p</em>, <em>h</em> 提供给 verifier。</li>
<li>verifier 验证 <em>p= t⋅h</em>，如果多项式相等，就意味着 <em>t(x)</em> 是 <em>p(x)</em> 的因式。</li>
</ul>
<p>实践一下，用下面的例子来执行这个协议：</p>
<ul>
<li>verifier 选一个随机数 23，并计算 <em>t</em> = <em>t</em>(23) = (23 – 1)(23 – 2) = 462，然后将 23 发给 prover</li>
<li>prover 计算 <em>h</em>(<em>x</em>) =<em>p</em>(<em>x</em>) / <em>t</em>(<em>x</em>) = <em>x</em>, 并对 <em>p(r)</em> 和 <em>h(r)</em> 进行求值，<em>p</em>= <em>p</em>(23) = 10626，<em>h</em>= <em>h</em>(23) = 23，将 <em>p</em> 和 <em>h</em> 提供给 verifier</li>
<li>verifier 再验证 <em>p= t⋅h</em>：10626 = 462 ⋅ 23 是正确的，这样陈述就被证明了。</li>
</ul>
<p>相反，如果 prover 使用一个不同的 <em>p</em>′(<em>x</em>) ，它并不包含必要的因式，例如 <em>p′(x) = 2x³ – 3x² + 2x</em>, 那么：</p>
<p><img src="img/1_heV9wqxECa2N4rG0OpvItQ.png" alt="" /></p>
<blockquote>
<p>@Maksym（作者）：虽然为了简化而使用了一组数学符号，但是如果忽视这个无处不在的基本符号：’(上撇)的话将不利于理解。这个符号本质目的是为了强调一个经过初始变量变换或者推导得到的新变量。即，如果我们想要将 v 乘以 2 并给将它赋值给一个新的变量，我们可以使用：v'= <em>2</em> ⋅ v。</p>
</blockquote>
<p>我们算出结果<em>2x + 3</em> 和余数<em>7x – 6</em>，即：<em>p(x) = t(x) × (2x+ 3) + 7x – 6</em>。这就意味着 verifier 为了计算出结果他不得不用 余数除以<em>t(x)</em>， $h(x) = 2x+3+\frac{7x-6}{t(x)}$。</p>
<p>不过由于 <em>x</em> 是 verifier 随机选择的，就有极低的概率余数 <em>7x – 6</em> 最终可以被 <em>t(x)</em> 整除。如果后面 verifier 要另外再检查 p 和 h 必须是整数的话，这个证明才会被拒绝。不过要这么校验就同时要求多项式系数也是整数，这对协议产生了极大的限制。</p>
<p>这就是为什么接下来我们要介绍能够使余数不被整除的密码学原理的原因，尽管这个原始值是有可能被整除的。</p>
<p><strong>Remark 3.1</strong> 现在我们就可以在不知道多项式的前提下根据特定的性质来验证多项式了，这就已经给了我们一些零知识和简明性的特性。但是，这个结构中还存在好多问题：</p>
<ul>
<li>prover 可能并不知道他所声称的 p(x)，他可以先算一下  <em>t</em> = <em>t(r)</em>，然后选择一个随机值 <em>h</em>，由此计算出 <em>p = t⋅h</em>。因为等式是成立的，所以也能通过 verifier 的校验。</li>
<li>因为 prover 知道随机点 <em>x = r</em> ，他可以构造出一个任意的多项式，这个任意多项式与 <em>t</em>(<em>r</em>) ⋅ <em>h</em>(<em>r</em>) 在 <em>r</em> 处有共同点。</li>
<li>在前面的「陈述」中，prover 声称他知道一个特定阶数的多项式，但现在的协议对阶数并没有明确的要求。因而 prover 完全可以拿一个满足因式校验的更高阶数的多项式来欺骗 verifier。</li>
</ul>
<p>下面我们就要来逐一得解决这些问题。</p>
<blockquote>
<p>even@安比实验室：利用因式的性质构造出了一个证明协议，但这个协议存在一些缺陷，主要是由于</p>
<ol>
<li>prover 知道了 t(r)，他就可以反过来任意构造一个可以整除 t(r) 的 p(r)</li>
<li>prover 知道了点(r,t(r) · h(r)) 的值，就可以构造经过这一点的任意多项式，同样满足校验</li>
<li>协议并没有对 prover 的多项式阶数进行约束</li>
</ol>
</blockquote>
<h2 id="模糊计算"><a class="header" href="#模糊计算">模糊计算</a></h2>
<p>Remark 3.1 中的前两个问题是由于 <strong>暴露了原始值</strong> 而导致的，也就是 prover 知道了 <em>r</em> 和 <em>t(r)</em>。但如果 verifier 给出的这个值像放在黑盒里一样不可见的话就完美了，也就是一个人即使不破坏协议，也依然能在这些模糊的值上面完成计算。有点类似哈希函数，从计算结果就很难再回到原始值上。</p>
<h3 id="同态加密"><a class="header" href="#同态加密">同态加密</a></h3>
<p>这也就是要设计同态加密的原因。它允许加密一个值并在密文上进行算术运算。获取加密的同态性质的方法有多种，我们来介绍一个简单的方法。</p>
<p>总体思路就是我们选择一个基础的（基数需要具有某些特定的属性）的自然数 <em>g</em>（如 5），然后我们以要加密的值为指数对 <em>g</em> 进行求幂。例如，如果我们要对 3 进行加密：</p>
<p>$5^3=125$</p>
<p>这里 125 就是 3 对应的密文。如果我们想要对被加密的值乘 2，我们可以以 2 为指数来对这个密文进行计算。</p>
<p>$125^2 =15625=(5^3)^2 =5^{2 \times 3} = 5^6$</p>
<p>我们不仅可以用 2 来乘以一个未知的值并保持密文的有效性，还可以通过密文相乘来使两个值相加，例如 3+2：</p>
<p>$5^3 \cdot 5^2 = 5^{3+2} =5^5 =3125$</p>
<p>同样的，我们还可以通过相除提取加密的数字，例如：5-3</p>
<p>$\frac{5^5}{5^3}  = 5^5 \cdot 5^{-3} = 5^{5-3} =5^2 =25$</p>
<p>不过由于基数 5 是公开的，很容易就可以找到被加密的数字。只要将密文一直除以 5，直到结果为 1，那么做除法的次数也就是被加密值的数。</p>
<h3 id="模运算"><a class="header" href="#模运算">模运算</a></h3>
<p>这里就到了模运算发挥作用的地方了。模运算的思路如下：除了我们所选择的组成有限集合的前 n 个自然数（即，<em>0</em>，<em>1</em>，…，<em>n</em>-<em>1</em>）以外，任何超出此范围的给定整数，我们就将它“缠绕”起来。例如，我们选择前六个数。为了说明这一点，可以把它看做一个有六个单位大小相等刻度的圆；这就是我们所说的范围（通常指的是有限域）。</p>
<p><img src="img/1_q-GtshK0LkZMg5PSj44FvA.png" alt="img" /></p>
<p>现在我们看一下数字八应该在哪里。打个比方，我们可以把它看成一条长度为 8 的绳子。<img src="img/1_WbT1Eie_Frg1vdqcfi_uig.png" alt="img" /></p>
<p>如果我们将绳子固定在圆圈的开头<img src="img/1_O-OE3lLnPelGiej4L56R3A.png" alt="img" /></p>
<p>然后用绳子缠绕圆圈，我们在缠完一圈后还剩下一部分的绳子。</p>
<p><img src="img/1_nOJ-DFp3L4fOYmHbkWp-JQ.png" alt="img" /></p>
<p>然后我们继续缠绕，这根绳子将在刻度 2 的地方终止。</p>
<p><img src="img/1_5970QxlFD23iOJrY8_DPsw.png" alt="img" /></p>
<p>这就是模运算操作的结果。无论这根绳子多长，它最终都会在圆圈一个刻度处终止。因而模运算结果将保持在一定范围内（例子中是 0 到 5）。长度为 15 的绳子将会在刻度 3 的地方终止，即 <em>6</em> + <em>6</em> + <em>3</em> （缠 2 个完整的圈并剩下 3 个单位长的部分）。负数运算类似，唯一不同的地方就是它是沿相反方向缠绕的，如 -8 的取模结果是 4。</p>
<p>我们执行算术运算，结果都将落在这 n 的范围内。现在开始我们将用符号 “<em>mod n</em>” 来表示这个范围内的数。</p>
<p><em>3 × 5 = 3 mod 6</em></p>
<p><em>5 + 2 = 1 mod 6</em></p>
<p>另外，模运算最重要的性质就是运算顺序无所谓。例如，我们可以先做完所有的操作，然后再取模，或者每操作完一步都去取模。例如  <em>(2 × 4 – 1) × 3 = 3  (mod 6)</em> 就等于：</p>
<p><em>2 × 4 = 1 mod 6</em></p>
<p><em>2 - 1 = 1 mod 6</em></p>
<p><em>1 × 3 = 3 mod 6</em></p>
<p>那么模运算到底有什么用呢？就是如果我们使用模运算，从运算结果再回到原始值并不容易，因为很多不同的组合会产生一个同样的运算结果：</p>
<p><em>5 × 4 = 2 mod 6</em></p>
<p><em>4 × 2 = 2 mod 6</em></p>
<p><em>2 × 1 = 1 mod 6</em></p>
<p><em>……</em></p>
<p>没有模运算的话，计算结果的大小会给找出原始值提供一些线索。除非这里既能把信息隐藏起来，又可以保留常见的算术属性。</p>
<h3 id="强同态加密"><a class="header" href="#强同态加密">强同态加密</a></h3>
<p>我们再回到同态加密上，使用模运算，例如取模 7，我们可以得到：</p>
<p>$5^1 =5(mod \quad 7)$</p>
<p>$5^2 =4(mod \quad 7)$</p>
<p>$5^3 =6(mod \quad 7)$</p>
<p>$……$</p>
<p>不同指数下运算得到了同样的结果：</p>
<p>$5^5 =3(mod \quad 7)$</p>
<p>$5^{11} =3(mod \quad 7)$</p>
<p>$5^{17} =3(mod \quad 7)$</p>
<p>$…$</p>
<p>这样就很难知道指数是多少了。事实上，如果模取得相当大，从运算结果倒推指数运算就不可行了；现代密码学很大程度上就是基于这个问题的“困难”。</p>
<p>方案中所有的同态性质都在模运算中保留了下来：</p>
<p>$encryption: 5^3=6(mod \quad 7)$</p>
<p>$multiplication: 6^2=(5^3)^2=5^6=1(mod \quad 7)$</p>
<p>$addition: 5^3 \cdot 5^2=5^5=3(mod \quad 7)$</p>
<p><em>注意：模相除有点难已经超出范围了。</em></p>
<p>我们来明确地说明一下加密函数：</p>
<p>$E(v)=g^v(mod \quad n)$</p>
<p><em>E(v) = gv(mod n)</em></p>
<p>这里 <em>v</em> 就是我们要加密的值。</p>
<p><strong>Remark 3.2</strong> 这个同态加密模式有一个限制，我们可以把一个加密的值和一个未加密的值相乘，但我们不能将两个加密的值相乘（或者相除），也就是说我们不能对加密值取幂。虽然这些性质第一感觉看起来很不友好，但是这却构成了 <em>zk-SNARK</em> 的基础。这个限制后面将在“加密值乘法”一节中讲到。</p>
<blockquote>
<p>even@安比实验室：通过模运算形成的集合被称为「有限域」，而通过计算指数再进行模运算形成的集合构成「循环群」。常见的同态加密方式除了整数幂取模之外，还有椭圆曲线上的倍乘。</p>
</blockquote>
<h3 id="加密多项式"><a class="header" href="#加密多项式">加密多项式</a></h3>
<p>配合这些工具，我们现在就可以在加密的随机数 <em>x</em> 上做运算并相应地修改<em>零知识</em> 协议了。</p>
<p>我们来看一下如何计算多项式 <em>p(x) = x³ – 3x² + 2x</em>。我们前面明确了，知道一个多项式就是知道它的系数，也就是这个例子中知道：1，-3，2。因为同态加密并不允许再对加密值求幂，所以我们必须要给出 <em>x</em> 的 1 到 3 次幂取加密值：<em>E</em>(<em>x</em>)<em>，E</em>(<em>x</em>²)<em>，E</em>(<em>x</em>³)，那么我们要计算的加密多项式就是：</p>
<p>$$E(x^{3})^{1} · E(x^{2})^{-3} · E(x)^{2} = (g^{x^{3}})^{1} · (g^{x^{2}})^{-3} · (g^x)^2 =  g^{1x^3} · g^{-3x^2} · g^{2x} = g^{x^3-3x^2+2x} $$</p>
<p>所以通过这些运算，我们就获得了多项式在一些未知数 <em>x</em> 处的加密计算结果。这确实是一个很强大的机制，因为同态的性质，同一个多项式的加密运算在加密空间中始终是相同的。</p>
<p>我们现在就可以更新前面版本的协议了，比如对于阶数为 <em>d</em> 的多项式：</p>
<ul>
<li>
<p>Verifier</p>
<ul>
<li>取一个随机数 <em>s</em> ，也就是秘密值</li>
<li>指数 i 取值为 0，1，…，d 时分别计算对 s 求幂的加密结果，即：$E(s^i) = g^{s^i}$</li>
<li>代入 <em>s</em> 计算未加密的目标多项式： $t(s)$</li>
<li>将对 <em>s</em> 求幂的加密结果提供给 prover：$E(s^0)$，$E(s^1)$，…，$E(s^d)$</li>
</ul>
</li>
<li>
<p>Prover</p>
<ul>
<li>
<p>计算多项式 $h(x) = p(x)/t(x)$</p>
</li>
<li>
<p>使用加密值 $g^{s^0}$，$g^{s^1}$，…，$g^{s^d}$ 和系数 $c_0$，$c_1$，…，$c_n$ 计算</p>
<p>$E(p(s)) = g^{p(s)} = (g^{s^d})^{c_d}…(g^{s^1})^{c_1} *(g^{s^0})^{c_0}$</p>
<p>然后同样计算 $E(h(s)) = g^{h(s)}$</p>
</li>
<li>
<p>将结果 $g^p$ 和 $g^h$ 提供给 verifier</p>
</li>
</ul>
</li>
<li>
<p>Verifier</p>
</li>
<li>
<ul>
<li>最后一步是 verifier 去校验 $p = t(s) ·h$: $ g^{p} = (g^{h})^{t(s)} =&gt; g^{p} = g^{t(s)·h} $</li>
</ul>
</li>
</ul>
<p><em>注意：因为证明者并不知道跟 s 相关的任何信息，这就使得他很难提出不合法但是能够匹配验证的计算结果。</em></p>
<p>尽管这个协议中 prover 的灵活性有限，他依然可以在实际不使用 verifier 所提供的加密值进行计算，而是通过其它的方式来伪造证明。例如，如果 prover 声称有一个满足条件的多项式它只使用了 2 个求幂值 $s^3$ 和 $s^1$，这个在当前协议中是不能验证的。</p>
<blockquote>
<p>even@安比实验室: 利用强同态加密这个工具，构造了一个相对较强的零知识证明协议。但是如上文所述，这里还是存在一些问题—— 无法验证 prover 是否是真的使用了 verifier 提供的值来构造证明的。</p>
<p>大家可以思考一下，如何解决这个问题？以及这个协议还存在哪些缺陷呢？</p>
<p>在下一节中，我们将会继续展开讨论，并展示如何构造一个完备的多项式的零知识证明协议。</p>
</blockquote>
<p><strong>参考文献</strong></p>
<p>[Bit+11] — Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. <em>From Extractable</em> <em>Collision Resistance to Succinct Non-Interactive Arguments of</em> <em>Knowledge, and Back Again</em>. Cryptology ePrint Archive, Report 2011/443. https://eprint.iacr.org/2011/443. 2011</p>
<p>[Par+13] — Bryan Parno, Craig Gentry, Jon Howell, and Mariana Raykova. <em>Pinocchio: Nearly Practical Verifiable Computation</em>. Cryptology ePrint Archive, Report 2013/279. https://eprint.iacr.org/2013/279. 2013</p>
<p>[Rei16] — Christian Reitwiessner. <em>zkSNARKs in a Nutshell</em>. 2016. url: https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/ </p>
<p>[But16] — Vitalik Buterin. <em>Quadratic Arithmetic Programs: from Zero to</em> <em>Hero</em>. 2016. url: https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649</p>
<p>[But17] — Vitalik Buterin. <em>zk-SNARKs: Under the Hood</em>. 2017. url: https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6 </p>
<p>[Gab17] — Ariel Gabizon. <em>Explaining SNARKs</em>. 2017. url: https://z.cash/blog/snark-explain/ </p>
<p>[Ben+14] — Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran Tromer, and Madars Virza. <em>Zerocash: Decentralized</em> <em>Anonymous Payments from Bitcoin</em>. Cryptology ePrint Archive, Report 2014/349. https://eprint.iacr.org/2014/349. 2014</p>
<p>[GMR85] — S Goldwasser, S Micali, and C Rackoff. “The Knowledge Complexity of Interactive Proof-systems”. In: <em>Proceedings of the Seventeenth Annual ACM</em> <em>Symposium on Theory of Computing</em>. STOC ’85. Providence, Rhode Island, USA: ACM, 1985, pp. 291–304. isbn: 0–89791–151–2. doi: <a href="https://doi.org/10.1145/22145.22178">10.1145/22145.22178</a>. url: http://doi.acm.org/10.1145/22145.22178</p>
<p>[BFM88] — Manuel Blum, Paul Feldman, and Silvio Micali. “Non-interactive Zero-knowledge and Its Applications”. In: <em>Proceedings of the Twentieth Annual ACM</em> <em>Symposium on Theory of Computing</em>. STOC ’88. Chicago, Illinois, USA: ACM, 1988, pp. 103–112. isbn: 0–89791–264–0. doi: <a href="https://doi.org/10.1145/62212.62222">10.1145/62212.62222</a>. url: http://doi.acm.org/10.1145/62212.62222</p>
<p>[Gro10] — Jens Groth. “Short pairing-based non-interactive zero-knowledge arguments”. In: <em>International Conference on the Theory and Application of Cryptology and</em> <em>Information Security</em>. Springer. 2010, pp. 321–340</p>
<p>[Gen+12] — Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. <em>Quadratic</em> <em>Span Programs and Succinct NIZKs without PCPs</em>. Cryptology ePrint Archive, Report 2012/215. https://eprint.iacr.org/2012/215. 2012</p>
<p>[Pik13] — Scott Pike. <em>Evaluating Polynomial Functions</em>. 2013. url: http://www.mesacc.edu/~scotz47781/mat120/notes/polynomials/evaluating/evaluating.html </p>
<p>[Pik14] — Scott Pike. <em>Dividing by a Polynomial</em>. 2014. url: http://www.mesacc.edu/~scotz47781/mat120/notes/divide_poly/long_division/long_division.html </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="abstract.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch02.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="abstract.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch02.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
