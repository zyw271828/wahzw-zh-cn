# 多变量操作数多项式

因为只有当所有的左操作数使用同一个变量的时候我们才可以设置一个值。但是如果左操作数中再多一个值 *d* 要怎么做呢：

![img](img/3/1*yAqgTjn5LB4qh465LhM6hA.png)

假如我们还使用相同的方法，我们无法分别得为每一个变量设置值，并且让这些变量乘到一起去。也就是说这个受限的多项式只能支持一个变量的情况。我们可以把*操作数多项式 l(x)* 分成*操作数的变量多项式*

$l_a(x)$ 和 $l_d(x)$*（注意下标）*

这与上一节的方法一致，*变量 a* 和 *b* 可以被*赋值* 并分别进行约束，然后加在一起就可以表示所有的左操作数变量了。因为我们将*操作数的变量多项式* 加在了一起，所以我们就要能够确保在每次计算中相加后的结果只表示所有*操作符多项式* 中的一个。

有了这个算术性质我们就可以逐一构造*操作数变量多项式* 了，这样如果*变量* 多项式在一个对应运算中被用做操作数，那么这一项就置为 1，否则就置为 0。0 跟任何值相乘结果都是零，当把他们相加在一起的时候也就可以忽略掉这一项。在我们的例子中这些变量多项式必须满足以下计算：

*l<sub>a</sub>(1) =1,  l<sub>a</sub>(2)=1,  l<sub>a</sub>(3)=0*

*l<sub>d</sub>(x)=0,  l<sub>d</sub>(2)=0,  l<sub>d</sub>(3)=1*

图中表示为：

![img](img/3/1*mPS0DWApQpziFbz9Almi1Q.png)

于是我们就可以将每个变量分开设置值，然后把他们加在一起来计算出操作数多项式，例如当 *a = 3* 和 *d= 2* 时：

![img](img/3/1*haDU8bsgI7xwmxHTVZUODw.png)

*注意：我们在一个值的后面使用下标表示它代表的变量，如, 3<sub>a</sub> 是一个用 3 实例化的变量 a。*

现在起我们用大写字母来表示这个复杂的 *操作符多项式*，即

*L(x) = al<sub>a</sub>(x) + dl<sub>d</sub>(x)*

计算结果为 *L*，也就是 *L=L(s)*。仅当每一个*操作数的变量多项式* 是由验证者约束的，结果才有效，与左多项式相关的交互应该相应得更改为：

- Setup

  - 构造 $l_a(x)$，$l_b(x)$ 使得它能够在对应的 “计算 x” 处为 1，在其他地方为 0。
  - 选择随机数 $s$，$α$
  - 计算并加密 *未赋值的变量多项式*： $g^{l_a(s)}$，$g^{l_d(s)}$
  - 计算变换后的这些多项式： $g^{αl_a(s)}$，$g^{αl_d(s)}$
  - 设置 *proving key*：$(g^{l_a(s)},g^{l_d(s)},g^{αl_a(s)},g^{αl_d(s)})$
  - 设置 *verification key*：$(g^α)$

- Proving

  - 为变量多项式赋值 a 和 d：$（g^{l_a(s)}）^a$，$(g^{l_d(s)})^d$
  - 对变换后的变量多项式做同样的赋值： $(g^{αl_a(s)})^a$，$(g^{αl_d(s)})^d$
  - 把所有赋值好的变量多项式加起来变成操作数多项式的形式：$g^{L(s)}=g^{al_a(s)} \cdot g^{dl_d(s)} = g^{al_a(s)+dl_d(s)}$
  - 提供左操作数的有效证明：$(g^{L(s)},g^{αL(s)})$

- Verification

  - 解析证明为 $（g^L,g^{L’}）$
  - 验证提供的多项式是否是最初提供的多个*未赋值的变量多项式* 的和：

    $e(g^{L'},g) = e(g^L,g^α)$ 这里也就是验证了 $αal_a(s) + αdl_d(s) = α \times (al_a(s) + dl_d(s))$

*注意：L(s) 和 αL(s) 代表所有的变量多项式并且由于 α 只用在计算变量多项式中，所以证明者没有别的选择只能在 setup 提供的原始加密值和变换后的加密值上赋予相同的系数做计算。*

结果，证明者：

- 除了“分配”值外，不能再修改它们的系数进而来修改*变量多项式* 了，因为证明者只拿到了这些多项式的加密值，也因为 s 必要次幂的加密值不能与它们的 α 变换值一起使用
- 不能通过另一个多项式相加去提供一个结果因为这样 *α*-比例关系将会被破坏掉
- 不能通过与其他的一些多项式 *u(x)* 相乘来修改操作数多项式，这样可能会使得修改后的值不成比例因为在预配对空间中无法进行加密乘法

*注意：如果我们加（或者减）一个多项式，如 l<sub>a</sub>(x)，就变成了另一个的多项式，即*

*l'<sub>d</sub>(x) = c<sub>d</sub>·l<sub>d</sub>(x)+c'<sub>a</sub>·l<sub>a</sub>(x)*

*这并非是多项式 l<sub>d</sub>(x)  的修改，而是 l<sub>a</sub>(x) 结果系数的变化，因为他们最终会被加到一起：*

*L(x)=c<sub>a</sub>·l<sub>a</sub>(x)+l'<sub>d</sub>(x) =(c<sub>a</sub>+c'<sub>a</sub>)·l<sub>a</sub>(x)+c<sub>d</sub>·l<sub>d</sub>(x)*

不过尽管证明者被限制了多项式的使用，他还有拥有一些可允许范围内的自由度：

- 当证明者决定不加入一些变量多项式 *lᵢ*(*x*) 来构造操作符多项式 *L(x)* 时依然是可以接受的，因为这和为它分配值为 0 是一样的：

  g<sup>al<sub>a</sub>(x)</sup> = g<sup>al<sub>a</sub>(x)+0l<sub>d</sub>(x)</sup>

- 如果证明者添加同一个变量多项式多次也是可以接受的因为这和一次分配多个值的和是一样的：

  g<sup>al<sub>a</sub>(x)</sup> · g<sup>al<sub>a</sub>(x)</sup> · g<sup>al<sub>a</sub>(x)</sup>= g<sup>3al<sub>a</sub>(x)</sup>

这些方法在右操作数和输出操作数 *R(x)* ，*O(x)* 上也同样适用。

> 译者注：总结一下本文证明协议的大致思路为：
>
> 1. 将要证明的程序转换为数学语言表达的形式（即加减乘除的计算）
> 2. 用多项式在某处的取值来进行计算以此表示数学计算，进而进行证明
> 3. 用多项式在多处的取值来进行计算表示多个数学运算，进而加以证明
> 4. 对证明的“程序”在不同计算中使用的相同的变量进行约束
>
> 当前的协议约束只解决了部分问题，还有诸多可以改进的地方，在下一节我们将对这些改进项展开讨论并给证明协议进行优化。
