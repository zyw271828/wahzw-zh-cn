# 变量多项式

有了前文介绍的方法来解决证明多个计算多项式的问题，我们就可以一次证明多个运算（如上百万个甚至更多）了，但是这个方案还有一个关键的缺点。

**如果证明中执行的“程序”在不同运算中使用了相同的变量作为操作数或输出**，例如：

*<font style="color:green">a</font> × <font style="color:blue">b</font> = <font style="color:red">r<sub>1</sub></font>*

*<font style="color:green">a</font> × <font style="color:blue">c</font> = <font style="color:red">r<sub>2</sub></font>*

这里 *a* 代表两个运算中的左操作符多项式，如：

![img](img/3/1*PMNd1I7dYeJhSqF8MD5wCg.png)

然而，因为我们的协议中是允许证明者为多项式设置任何系数的，所以他可以不受限制得为不同计算（即，用一些 *x* 表示的多项式）中的 *a* 设置不同的值，即：

![img](img/3/1*HO_ZD_vp-c7LZK-IDxJo3A.png)

**这个自由打破了一致性**，有空间允许证明者能去证明了一些并非验证者感兴趣的其它无关的程序执行。因而我们必须要确保每一个变量在所有运算中出现的地方都只有一个取值。

*注意：文中的变量与常规的计算机科学中变量的定义不同，这里的变量是不可改变的而且每次执行都只赋值一次。*

> 译者注：请务必注意“变量”的定义，它是程序中的变量，但是却又不能改，这不是很矛盾吗？其实，这里变量是指本文开头的示例伪代码中的那些不会被修改的变量。在 zkSNARK 论文中，这个「变量」其实有一个对应的名词叫做 assignment，是算术电路的「赋值」。而所有的assignments 是一个算术电路可满足性问题的解，包含了算术电路的输入值以及电路运算过程中输出的中间结果值。
