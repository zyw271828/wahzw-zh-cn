# 非交互性

到现在为止，我们已经有了一个交互式的零知识方案。但为什么我们还需要有非交互式的呢？因为交互式证明只对原始的验证者有效，其他任何人（其他的验证者）都不能信任这个证明，因为：

* 验证者可以和证明者串通，告诉他秘密参数 \\(s, \alpha\\)，有了这些参数，证明者就可以伪造证明，就像前面备注 3.1 提到的那样
* 验证者也可以使用同样的方法自己伪造证明
* 验证者在所有相关证明被验证完毕之前必须保存 \\(\alpha\\) 和 \\(t(s)\\)，这就带来了一个可能造成秘密参数泄漏的额外攻击面

因此，为了证明一个陈述（在这种情况下是多项式知识），需要与每个验证者进行单独的交互。

尽管交互式证明也有它的用处，例如一个证明者只想让一个特定的验证者（称为指定验证者，即 Designated Verifier，更多信息参见 [[JSI96](./references.md#JSI96)]）确信，就不能再重复利用同一个证明去向别人证明这个声明了，但是当一个证明者想让众多的参与者同时（例如在区块链等分布式系统中）或者永久地确信的话，这种方法就很低效了。证明者需要一直保持在线并对每一个验证者执行相同的计算。

因而，我们就需要一个可以被重复使用、公开、可信，又不会被滥用的秘密参数。

我们先来思考一下如何在构造出秘密值（\\(t(s), \alpha\\)）之后保证它们的安全性。我们可以像验证者在发送给证明者之前加密 \\(s\\) 的幂一样对它们进行加密。但是备注 3.2 中提到，我们使用的同态加密并不支持两个秘密值相乘，这一点对 \\(t(s)\\) 和 \\(h\\) 的加密值相乘以及 \\(p\\) 和 \\(\alpha\\) 的加密值相乘的验证都很重要。这正是密码学配对（Cryptographic Pairing）适用的地方。

> 译者注：这里的非交互证明协议将对参数加密，但引入了两个问题：
>
> 1. 同态加密无法对两个加密值做乘法，如何验证加密后的参数？
> 2. 加密值一旦泄露，协议的信任关系将无法保证，如何确保参数的安全性？
