# 限制多项式

上文说到，多项式的知识其实就是它的系数 *c<sub>0</sub>, c<sub>1</sub>, …, c<sub>i</sub>* 的知识。协议中我们是通过对秘密值 *s* 的幂的加密值再进行求幂来对系数进行“赋值”。我们已经限制了证明者对 *s* 幂的加密值的选择, 但是这个限制并不是强制的  ，也就是说，证明者可以使用任何可能的方法找到满足下面等式的值  *z<sub>p</sub>* 和 *z<sub>h</sub>*

$$z_p = \left(z_h\right)^{t(s)}$$

再用这两个值来代替  *gᵖ*  和 *gʰ*  将它交给验证者。所以验证者需要能够证明证明者给出的值就是用 *s* 幂的加密值而不是其它值计算出来的。

我们看一个由一个变量和一个系数组成的一阶多项式的简单例子，对应的 *s* 的加密值为 *E(s) = gˢ*。这里我们要做的就是确保证明者是拿 *s* 的加密值，即 *gˢ* ，而不是其他值与系数 *c* 做同态相乘的。所以结果一定是这个形式（*c* 为任意值）：

$$\left(g^s\right)^c$$

解决这个问题的一种方法就是用另一个“变换”的加密值做同样的操作，充当类似算术中“校验和”*（Checksum）*  的作用，以此确保结果是原始值的求幂值。

这个是通过 **Knowledge-of-Exponent Assumption (简称 KEA)** 方法来实现的，在  [[Dam91](#bd26)] 中有介绍，更精准一点（注意 *a* 和 *α*(alpha)这两个字符的不同）说：

a）Alice 有一个值 *a*，她想要 Bob 对其进行任意指数的求幂（这里 *a* 是一个有限域群的生成器），唯一的要求是只能对  *a* 进行求幂，为了保证这一点，她要：

* 选择一个随机数 *α*
* 计算 *a' = a <sup>α</sup>(mod n)​*

* 提供一个元组 *(a, a')* 给 Bob, 然后让他对这两个值执行任意的求幂运算，返回结果元组 *(b, b')*，这里的指数 “α-变换” 依然保持不变，即 *b<sup>α</sup> = b'(mod n)​*

b) 因为 Bob 无法从元组 *(a, a')* 中提取 *α* 的值，通过暴力破解也难以实现，那就可以推断 Bob 生成有效元组的唯一方法就是执行下面的步骤：

* 选择一个值 c
* 计算 b=(a)<sup>c</sup>(mod n) 和 b' = (a')<sup>c</sup> (mod n)
* 回复 *(b,b')*

c) 有了回复的元组和 *α*，Alice 就可以验证等式：

  $$(b)^\alpha = b'$$

  $$\left(a^c\right)^\alpha = {(a')}^c$$

  $$a^{c \cdot \alpha} = {\left(a^\alpha\right)}^c$$

结论是：

* Bob 在元组的两个值的计算上都用了同一个指数（即 *c*）
* Bob 只能用 Alice 原本的元组来保持 *α* 关系
* Bob 知道指数 *c*，因为构造验证值 (*b,b*′) 的唯一方式是用同一个指数
* Alice 并不知道 *c*，这和 Bob 不知道 *α* 的原因一样
* 虽然 *c* 是被加密的，但它的可能取值范围并不足够大到保持其零知识的性质，这个问题我们将在后面“零知识”那一节解决。

最后这个协议提供了一个证明给 Alice ，Bob 确实是用他知道的某个值对 *a* 进行求幂的，而且他也不能做别的任何操作，例如：乘法，加法，因为这样就会破坏 α-变换关系。

在同态加密中，求幂是对被加密值进行乘法运算。我们可以应用这个结构到一个简单的系数多项式 *f*(*x*) = *c*⋅ *x*的例子中：

*验证者选择随机数*s*,*α*，然后提供令*x=s* 的一阶及其转换的计算值：

  $$\left(g^s, g^{\alpha \cdot s}\right)$$

*证明者代入系数 c 计算:

  $$\left( \left(g^s\right)^c, \left(g^{\alpha \cdot s}\right)^c \right) = \left(g^{c \cdot s}, g^{\alpha \cdot c \cdot s}\right)$$

*验证者验证：

  $$\left(g^{c \cdot s}\right)^\alpha = g^{\alpha \cdot c \cdot s}$$

这个结构“限制”证明者只能用验证者提供的加密的 *s* 进行计算，因而证明者只能将系数 c 赋给验证者提供的多项式。现在我们可以扩展这种单项式上的方法到多项式上，因为计算是先将每项的分配分开计算然后再 “同态地” 相加在一起的（这个方法是 Jens Groth 在 [[Gro10](#3068)] 中介绍的）。所以如果给定证明者一个指数为 *s* 的幂以及它们的变换的加密值，他就可以计算原始的和变换后的多项式，这里也必须要满足同样的校验。对于阶数为 *d* 的多项式：

*验证者提供加密值 $g^{s^0}$,$g^{s^1}$,…,$g^{s^d}$ 和他们的变换  $g^{αs^0}$,$g^{αs^1}$,…,$g^{αs^d}$

* 证明者:

  * 计算给定的带有 s 的幂的加密多项式

    $$g^{p(s)} = \left(g^{s^0}\right)^{c_0} \cdot \left(g^{s^1}\right)^{c_1} \cdot \ldots \cdot \left(g^{s^d}\right)^{c_d} = g^{c_0 s^0 + c_1 s^1 + \ldots + c_d s^d}$$

  * 计算给定的带有 s 的幂的转换的加密“转换”多项式：

    $$ g^{\alpha p(s)} = \left(g^{\alpha s^0}\right)^{c_0} \cdot \left(g^{\alpha s^1}\right)^{c_1} \cdot \ldots \cdot \left(g^{\alpha s^d}\right)^{c_d} = g^{c_0 \alpha s^0 + c_1 \alpha s^1 + \ldots + c_d \alpha s^d} = g^{\alpha (c_0 s^0 + c_1 s^1 + \ldots + c_d s^d)}$$

  * 将计算结果 $g^p$,$g^{p'}$ 发给verfier

*验证者校验：$(g^p)^α = g^{p'}$

前面的多项式例子 *p(x) = x<sup>3</sup> - 3x<sup>2</sup> +2x* 就变成了：

*验证者提供 $E(s^3)$, $E(s^2)$, $E(s)$ 和它们的变换  $E(αs^3)$, $E(αs^2)$, $E(αs)$

*证明者计算：

  $$g^p = g^{p(s)} = \left(g^{s^3}\right)^1 \cdot \left(g^{s^2}\right)^{-3} \cdot \Big(g^s\Big)^2 = g^{s^3} \cdot g^{-3s^2} \cdot g^{2s} = g^{s^3 - 3s^2 + 2s}$$

  $$g^{p'} = g^{\alpha p(s)} = \left(g^{\alpha s^3}\right)^1 \cdot \left(g^{\alpha s^2}\right)^{-3} \cdot \Big(g^{\alpha s}\Big)^2 = g^{\alpha s^3} \cdot g^{-3 \alpha s^2} \cdot g^{2 \alpha s} = g^{\alpha(s^3 - 3 s^2 + 2s)}$$

*验证者校验：$(g^p)^α = g^{p'}$

  $${\left(g^{s^3 - 3s^2 + 2s}\right)}^\alpha = g^{\alpha(s^3 - 3 s^2 + 2s)}$$

  $$g^{\alpha(s^3 - 3 s^2 + 2s)} = g^{\alpha(s^3 - 3 s^2 + 2s)}$$

现在我们就可以确保证明者是用了验证者提供的多项式而不是其它值做计算的了，因为别的方法不能够保持 α-变换。 当然如果验证者想要确保在证明者的多项式中排除了 s 的某些次幂，如 j， 他就不提供对应的密文及其变换：

$g^{s^j}，g^{αs^j}$

与前面的协议相比，我们现在已经有了一个比较健壮的协议。但是尽管已经做了加密，在*零知识* 性质上也还依然存在一个很明显的缺陷：*即理论上多项式参数 c<sub>ᵢ</sub> 是一个很广的取值范围内的值，实际上这个范围可能很有限*（比如前面例子中的 6），这就意味着验证者可以在有限范围的系数组合中进行暴力破解，最终计算出一个与证明者的答案相等的结果。比如我们将每个系数的取值范围定为 100，多项式阶数为 2，那么大概会有 100 万种不同的组合，这里可以认为暴力破解只需要少于 100 万次的迭代。更重要的是，即使在只有一个系数，值为 1 的例子中，安全协议也应该能够保证其安全。

> 译者注：有了 KEA，就可以约束证明者只能通过用验证者提供的加密值去构造证明了。严格点讲，这里是用的是 KEA的扩展版本，叫做 The q-power Knowledge of Exponent Assumption.
