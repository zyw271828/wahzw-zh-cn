# 运算证明

现在我们来修改一下最新协议使它支持单个乘法计算的证明。回到前面**多项式的 SNARK**一章，我们已经能够证明多项式 *p(x)* 的知识了，只不过现在要计算的是三个多项式 *l*(*x*)*, r*(*x*)*, o*(*x*)的知识。我们可以定义 *p*(*x*) = *l*(*x*) × *r*(*x*) – *o*(*x*)，但这里存在两个争议点。首先，在我们的协议中证明阶段是不能做加密值乘法计算的（即， *l*(*s*) × *r*(*s*)），因为配对只能用一次，这个要用在校验多项式的约束上。第二，这里给证明者留下了一个可以修改多项式结构但依然保留有效因式 *t(x)* 的机会，例如可以令 *p*(*x*) = *l*(*x*) 或者  *p*(*x*) = *l*(*x*) – *r*(*x*) 甚至是 *p*(*x*) = *l*(*x*) × *r*(*x*) + *o*(*x*)，只要这里的 *p(x)* 还保留着根 *a* 就可以了。这个修改本质上是让证明的内容变成了别的声明，所以这样是不行的。

所以 证明者 必须要分别提供多项式 *l*(*s*), *r*(*s*), *o*(*s*) 值的证明，即协议必须修改要证明的*多项式的知识*。验证者在加密空间中要验证的是  *l*(*s*) × *r*(*s*) – *o*(*s*) = *t*(*s*)*h*(*s*)。验证者可以使用密码学配对来执行乘法，但还有一个小问题就是做减法(– *o*(*x*))是非常昂贵的计算（这需要去找到一个 *gᵒ⁽ˢ⁾* 的逆向转换），这里我们可以把 *o*(*x*) 移到等式右边来： *l*(*x*)*r*(*x*) = *t*(*x*)*h*(*x*) + *o*(*x*)。在加密空间中，验证者的验证就可以转换成：

*e(g<sup>l(s)</sup>, g<sup>r(s)</sup>) = e(g<sup>t(s)</sup>,g<sup>h(s)</sup>) · e(g<sup>o(s)</sup>,g)*

*e(g,g)<sup>l(s)r(s)</sup> =e(g,g)<sup>t(s)h(s)</sup> ·e(g,g)<sup>o(s)</sup>*

*e(g,g)<sup>l(s)r(s)</sup> =e(g,g)<sup>t(s)h(s)+o(s)</sup>*

*注意：回忆一下加密配对的结果是支持通过乘法实现加密值的相加的，参见 **加密值相乘** 这一章节*

保持 *setup* 阶段不变，协议更新为：

- 证明

  - 分配对应的系数给 $l(x)$，$r(x)$，$o(x)$
  - 计算多项式 $h(x) = \frac{l(x) \times r(x)-o(x)}{t(x)}$
  - 使用 $\{g^{s^i}\}_{i\in[d]}$ 计算加密多项式 $g^{l(s)},g^{r(s)},g^{o(s)}$ 和 $g^{h(s)}$
  - 使用 $\{g^{\alpha s^i}\}_{i\in{0,…,d}}$ 计算加密多项式 $g^{αl(s)},g^{αr(s)},g^{αo(s)}$
  - 设置证明 $π = (g^{l(s)},g^{r(s)},g^{o(s)},g^{h(s)},g^{αl(s)},g^{αr(s)},g^{αo(s)})$

- 验证

  - 定义证明 $π$ 为 $(g^l,g^r,g^o,g^h,g^{l'},g^{r'},g^{o'})$
  - 检查多项式约束

    $e(g^{l'},g) = e(g^l,g^α)$

    $e(g^{r'},g) = e(g^r,g^α)$

    $e(g^{o'},g) = e(g^o,g^α)$

  - 检查运算的有效性 $e(g^l,g^r) = e(g^{t(s)},g^h) \cdot e(g^o,g)$

这个协议就能够证明两个值相乘的计算结果是正确的了。

你可能注意到了在这个新的协议中我们放弃了*零知识* 部分。这么做是为了简化协议的变换。后面的章节我们会再变回零知识。

> 译者注：上面例子里面取 x=1 这个特殊值作为运算编码的位置。当然这里的 1 可以换成任何别的值，比如说换成 x=2，3，或101 等等。在[GGPR]与[PHGR]论文中，这个取值是一个随机值，被称为 “root”。
