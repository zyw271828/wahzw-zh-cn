# 跨操作数的变量一致性

对于任意的变量 vᵢ ，我们都必须将它的值 *分配* 到每个相应操作数中的一个与之对应的*变量多项式* 上，即：

$(g^{l_i(s)})^{v_i}, (g^{r_i(s)})^{v_i},(g^{o_i(s)})^{v_i}$

因为每一个*操作数运算符* 的有效性是分开校验的，并不强制要求我们在对应的*变量多项式* 中使用相同的变量值。这就意味着在左操作数中变量 *v*₁ 的值可以与右操作数或输出中的变量值 *v*₁不同。

我们可以通过熟悉的限制多项式的方法（也就是限制变量多项式的方法）在操作数之间强制变量值相等。如果我们能够在所有的操作数之间创造一个作为“变换的校验和”的变量多项式，那么就可以限制证明者使其只能够赋予相同的值。验证者可以将这些每个变量的多项式加起来，即：

$g^{l_i(s)+r_i(s)+o_i(s)}$

然后乘以一个额外的随机数 *β*，即

$g^{β(l_i(s)+r_i(s)+o_i(s))}$

提供这些变换后的多项式给证明者，与变量多项式一起给它赋上变量值：

$(g^{l_i(s)})^{v_{L,i}},(g^{r_i(s)})^{v_{R,i}}, (g^{o_i(s)})^{v_{O,i}}, (g^{β(l_i(s)+r_i(s)+o_i(s))})^{v_{β,i}}$

然后加密 *β* 并把 $g^β$ 加到 *verification key* 中。现在如果所有的 *vᵢ* 值相同，即,

$v_{L,i} = v_{R,i} = v_{o,i} = v_{β,i} \quad 其中  i \in \{1,…,n\}$

等式就满足：

$e(g^{v_{L,i} \cdot l_i(s)} \cdot g^{v_{R,i} \cdot r_i(s)} \cdot g^{v_{o,i} \cdot o_i(s)},g^β)=e(g^{v_{β,i} \cdot β(l_i(s)+r_i(s)+o_i(s))},g)$

尽管这个一致性校验很有用，但还是存在一定的概率  *l*(*s*)*, r*(*s*)*, o*(*s*) 中至少有两项要么计算值相同要么一个多项式可以被另一个整除等情况，这就允许证明者去分解 $v_{L,i},v_{R,i},v_{O,i},v_{β,i}$ 这些值的关系，使得即使有至少两个不相等的值也依然能够保持等式成立，从而使校验无效：

$(v_{L,i} \cdot l_i(s) + v_{R,i} \cdot r_i(s) + v_{O,i} \cdot o_i(s)) \cdot β = v_{β,i} \cdot β \cdot (l_i(s) + r_i(s) + o_i(s))$

例如，一个以  *l*(*x*) = *r*(*x*) 为例的单个运算。我们用 *w* 来表示这两个值同时  *y* = *o*(*s*)。这个等式看起来就是：

$β(v_Lw + v_Rw+v_Oy) = v_β \cdot β(w+w+y)$

对于任意的 $v_R$ 和 $v_O$，这种形式可以令 $v_β = v_o$，$v_L = 2v_o -v_R$，也就变换成：

$β(2v_ow - v_Rw + v_Rw + v_oy) = v_o \cdot β(2w+y)$

因而这样一个一致性策略是无效的。缓解这种情况的一种方法是对每个操作数都使用不同的 β，确保操作数的*变量多项式* 中包含无法预测的值。以下就是修改后的协议：

* Setup

  * … 随机数 $β_l$， $β_r$， $β_o$
  * 对*变量一致性多项式* 进行计算，加密并添加到 proving key中：

    ${g^{β_ll_i(s)+ β_rr_i(s)+ β_oo_i(s)}}_{i \in \{1,…,n\}}$

  * 对 $β_s$ 加密并将其加到 *verification key* 中：$(g^{β_l},g^{β_r},g^{β_o})$

* Proving
  * …将变量值赋给*变量一致性多项式*：

    $g^{z_i(s)} = (g^{β_ll_i(s)+ β_rr_i(s)+ β_oo_i(s)})^{v_i} \quad for \quad i \in \{1,…,n\}$

  * 增加分配的多项式到加密空间中:

    $g^{Z(s)} = \prod_{i=1}^n{g^{z_i(s)}} = g^{β_lL(s) + β_rR(s)+ β_oO(s)}$

  * 再在证明中加入：$g^{Z(s)}$

* Verification
  * …校验提供的*操作数多项式* 和 “校验和”多项式之间的一致性：

    $e(g^L,g^{β_l}) \cdot e(g^R,g^{β_r}) \cdot e(g^O,g^{β_o}) = e(g^Z,g)$

    这相当于：

    $e(g,g)^{β_lL + β_rR + β_oO} =e(g,g)^Z$

这个构造中同一个变量值就无法乱用了，因为不同的 *β<sub>s</sub>* 使得相同多项式无法兼容，但是这里还存在与  **备注 4.1** 相同的缺陷，由于*g<sup>β<sub>l</sub></sup>*  ，*g<sup>β<sub>r </sub></sup>*， *g<sup>β<sub>o </sub></sup>*是公开可见的，攻击者可以修改任意变量多项式的零索引系数，因为它并不依赖于 *s*，即，*g<sup>β<sub>l</sub>s<sup>0</sup></sup>= g<sup>β<sub>l</sub></sup>*。

> 译者注：回忆一下，上文中我们提出了在 setup 阶段设置数学表达式的约束关系来解决了一些问题，但这里似乎有引入了一个问题：如果保证证明者构造的证明是用遵循这些约束关系计算出来的呢？
>
> KEA 其实已经解决了这个问题，但似乎并不完美，这就是我们下面要讨论的变量延展性问题。
