# 单变量操作数多项式

我们来看一个简单的例子（就是当前的例子），在*左操作符多项式 l(x)* 表示的所有左操作数中只包含一个变量（即 *a*）。我们要找出是否有可以确保这个多项式在每一个运算中 *a* 都相同的方法。证明者可以设置不同值是因为他可以任意控制 *x* 的每个次幂的系数。因而如果这些系数是固定的，就可以解决问题了。

我们来仔细看看包含相等值的多项式。例如检查一下下面两个多项式，他们分别都表示了有两个相等值对应的运算（即在 x=1 和 x=2 处），这里第一个多项式的值为 1，第二个多项式的值为 2：

![img](img/3/1*sVoDxQA6KHkuEJAZvsL8xQ.png)

注意每个多项式中相应的系数是成比例的，也就是第二个多项式的系数是第一个的两倍大，即：

*2x<sup>2</sup>-6x+6=2×(x<sup>2</sup> -3x+3)*

那么由于多项式的算术性质，如果我们想要同时地改变多项式中所有的值我们就需要改变它的比例，如果我们用一个数字乘以多项式，那么在每一个可能的 *x* 处的计算结果也要和相同的数字相乘（即，等比例变换）。为了验证这一点，我们尝试用 3 或者其它数字来乘第一个多项式。

因此，**如果验证者需要在所有计算中强制证明者设置相同的值，他就要限制证明者只能修改比例而不是单个系数**。

所以怎么保持系数比例不变呢？对于这个问题我们可以先思考一下在*左运算多项式* 中我们提供的证明是什么。是 *l(x)* 在一些秘密值 *s* 处的加密值：*g<sup>l(s)</sup>*，即，一个被加密了的数。我们已经从 **限制多项式** 这一节中知道了怎样通过一个*α*-变换去限制证明者只能使用验证者提供的 s 的幂做计算，来使得单个运算能够满足同态乘法。

和限制单个求幂值相似，verfier 可以一次限制完整的多项式。而不只是提供单独的加密及其 α-移位 *g<sup>s<sup>1</sup></sup>*,*g<sup>s<sup>2</sup></sup>*,…,*g<sup>s<sup>d</sup></sup>*,*g<sup>αs<sup>1</sup></sup>*,*g<sup>αs<sup>2</sup></sup>*,…,*g<sup>αs<sup>d</sup></sup>*。

那么协议的过程就是：

- Setup
  - 使用对应的系数构造相应的*操作符多项式 l(x)*
  - 选择随机数 *α* 和 *s*
  - 使用加密的 *l(s)* 和它的”转换“：$(g^{l(s)},g^{αl(s)})$ 来设置 *proving key*
  - 设置 *verification key*：$(g^α)$
- proving
  - 对于操作数值 *v*
    - 乘以操作数多项式：$(g^{l(s)})^v$
    - 乘以变换后的操作数多项式：$(g^{αl(s)})^v$
  - 提供 *操作数多项式* 的乘法证明： $(g^{vl(s)},g^{vαl(s)})$
- verification
  - 解析证明为 $(g^l,g^{l'})$
  - 验证比例：$e(g^{l'},g) = e(g^l,g^α)$

证明者需要返回同样的*α*-转换关系，因为无法从 proving key 中恢复出 *α* 所以保持这个变换的唯一方法就是用同一个值去分别乘以这两个加密值：*g<sup>l(s)</sup>* 和 *g<sup>αl(s)</sup>*。这个证明者就无法修改 *l(x)* 的单个系数了，例如如果多项式为 l(x) = ax<sup>2</sup> + *bx*+ c ，证明者只可以用一个值 *v* 去修改整个多项式： v⋅(ax<sup>2</sup> + *bx*+ *c*) = v⋅ax<sup>2</sup> + *v⋅bx*+ v⋅c。*配对* 使其不能与另一个多项式做乘法，所以也就无法提供 *s* 的单个求幂值的 *α-*变换。证明者不能做加法或者减法因为：

$g^{α(l(x)+a'x^2+c')} \not= g^{αl(x)} \cdot g^{a'x^2} \cdot g^{c'}$ 这里也同样需要未加密的 *α* 的知识。

现在有了这个协议，不过怎么去构造*操作数多项式 l(x)* 呢？由于任何整数都可以通过乘以 1 得到它本身，所以多项式中对应的每个计算结果都应该为 1，即：

![img](img/3/1*OD_cyAXNCBB62DVBe815qA.png)

然后再让证明者在其上”分配“一个值 a ：

![img](img/3/1*qNsslAIXLSPq5MWf4TCpqw.png)

**备注 4.1** *由于 verification key 包含了加密了的 α，所以可以用多项式加（或者减）任意一个值 v'，即：*

$g^{vl(s)} \cdot g^{v'} = g^{vl(s)+v'}$

$g^{αvl(s)} \cdot (g^α)^{v'} = g^{α(vl(s)+v')}$

$e(g^{α(vl(s)+v')},g) = e(g^{vl(s)+v'},g^α)$

*因而可以修改多项式使其超出验证者的预期以及证明一个不同的声明，后面的章节我们将会解决掉这个问题。*

> @译者注：这一小节是解决这样一个问题，算术电路中一个 input wire 或者 output wire可能同时会作为多个门的输入wire，如何确保约束这些公用wire的问题。
>
> 由于要证明的数学表达式是公开的，那么各个算式之间的约束关系也就是公开的，那么我们就可以把构造多项式的工作交给 setup 环节，这样证明者只要填上对应的数值就可以了。
>
> 上文这个方法就限制了在同一个操作数多项式上，不同的计算式中使用的同一个值的约束关系；同样若一个操作数多项式中用到了多个值，也可以将这些值全都加起来，如下文所述。
