# 加法、减法和除法

到目前为止，我们一直专注于乘法操作。但是为了能够执行通用计算，真实环境下的程序也需要加法，减法和除法。

**加法** 在前面的章节中，我们已经确定了可以在单个操作数的内容中将变量加起来，然后和另一个操作数相乘，即(3*a* + *b*) × *d* = *r* ，但是如果我们只是想做加法，没有乘法，例如一个程序中需要做  a + b 的计算，我们可以按照下面的方式来表示： *(a+b) × 1 = r​*

> 注：因为我们的结构中对于每一个操作数我们既需要常量系数也需要变量 (c ⋅ v) ，1 这个值可以表示为  c*₁* ⋅ v*₁*，其中  c*₁* = *1* 可以被“硬编码”到对应的多项式中， v*₁* 是一个变量可以给它分配任何值，那么我们就必须通过一些约束来限制 v*₁* 的值，这个在后面的章节中将会讲到。

**减法** 减法与加法几乎一致，唯一的不同就是负系数， a-b也就是：

$\textcolor{green}{(a+-1 \cdot b)} \times \textcolor{blue}{1} = \textcolor{red}{r}$

**除法** 如果我们检查除法运算

$\frac{factor}{divisor} = result$

可以看到除法的结果是就是我们要得到一个结果值使其乘以 divisor 能够得到 factor。所以我们也可以用乘法来表示出同一个意思：*divisor × result = factor*。这样就是说如果我们想要去证明除法运算 *a / b= r*，我们就可以把它表示为：

$\textcolor{green}{b} \times \textcolor{blue}{r} = \textcolor{red}{a}$

> 注：运算的结构也称为 “约束” ，因为多项式结构代表的运算，并非是为了计算出结果，而是在证明者已经知晓的变量赋值的情况下，检验这个运算的过程是否正确。换句话说，即约束证明者必须提供一致的值，无论这些值是什么。
>
> 所有的算术计算（加减乘除）都已经有了，于是运算结构不再需要修改。  

> 译者注：约束和运算有一定的关联性。算术电路的目的是为了实现「计算的验证」，而非「计算的过程」。
>
> 上一篇文章中，我们提出了一种方法：把构造多项式的工作交给 setup 环节，证明者只要填上对应的数值就可以了。 这个方法不仅解决了同一个操作数运算符中不一致的问题，同时还带来了额外的便利：
>
> 1）允许执行计算的表达式中包含静态系数。
>
> 2）虽然l(x)·r(x)=o(x)的关系中只有乘法，但利用这个方法也可以轻松的执行加法操作，继而也就解决了减法和除法的问题。
