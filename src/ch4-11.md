# 公开输入和一

如果不能根据验证者的输入对其进行检查，那么证明的可用性将受到限制。也就是说，虽然知道证明者将两个值相乘但是并不知道这些值和/或计算结果。尽管有可能在 *proving key* 中通过“硬编码”来进行验证一些特定的值（如，乘法运算的结果必须为12），但这就需要针对每一个想要的“验证者的输入”生成单独的密钥对。

> 译者注：这样会严重限制实用性，电路需要支持参数。

**因而如果可以由验证者而不是证明者为计算指定一些值（输入或者输出），包括 $v_{one}$，那证明就可以变得更通用了。**

首先，我们看一下要证明的值 g<sup>L(s)</sup>，g<sup>R(s)</sup>，g<sup>O(s)</sup>。因为这里使用了同态加密所以可以增大这些值，例如，我们可以与另一个加密的多项式相加使得值为*g<sup>L(s)</sup> · g<sup>l<sub>v</sub>(s)</sup> =g<sup>L(s)+l<sub>v</sub>(s)</sup>* 。

这样如果我们能够在提供给证明者的变量多项式中排除必要的一项，验证者就可以在这一项变量多项式上设置他自己的值，并且使得检查依然能够通过。

因为验证者已经可以通过加入α-转换来限制证明者选择多项式了，所以这个检查结果就很容易得到。因而当消除了它的 α<sub>s </sub>和 *β* 校验和对应的项，这些可变多项式就可以从 *proving key* 转移到 *verification key* 当中去了。

必要的协议更新为：

* Setup
  * …将 n 个可变多项式全部分为两组：

    *验证者的*m+1* 项：$L_v(x) = l_0(x) + l_1(x) +…+l_m(x)$,对 $R_v(x)$ 和 $O_v(x)$ 也做同样的计算。这里对于索引0 保留值 $v_{one} =1$

    *证明者的*n-m* 项：

      $L_p(x) = l_{m+1}(x) +…+l_n(x)$，对 $R_p(x)$ 和 $O_p(x)$ 也做同样的计算。

  * 设置 *proving key*：$(\{g^{s^k}\}_{k \in [d]},\{g_l^{l_i(s)},g_r^{r_i(s)},g_o^{o_i(s)},g_l^{α_ll_i(s)},g_r^{α_rr_i(s)},g_o^{α_oo_i(s)},g_l^{βl_i(s)},g_r^{βr_i(s)},g_o^{βo_i(s)}\}_{i \in \{m+1,…,n\}})$

  * 添加到 *verification key*：$(……，\{g_l^{l_i(s)}, g_r^{r_i(s)}, g_o^{o_i(s)}\}_{i \in \{0,…,m\}})$

* Proving
  * …为验证者的多项式计算 *h(x)*：$h(x) = \frac{L(x) \cdot R(x) -O(x)}{t(x)}$，其中 $L(x) = L_v(x) + L_p(x)$，$R(x)$ ，$O(x)$ 也通过同样的计算获得。

  * 提供证明：

    $(g_l^{L_p(s)},g_r^{R_p(s)},g_o^{O_p(s)},g_l^{α_lL_p(s)},g_r^{α_rR_p(s)},g_o^{α_oO_p(s)},g^{Z(s)},g^{h(s)})$

* Verification
  * 为验证者的变量多项式赋值，并加 1：

    $g_l^{L_v(s)} = g_l^{l_0(s)} \cdot \prod_{i=1}^m{(g_l^{l_i(s)})^{v_i}}$，对 $g_r^{R_v(s)}$ 和 $g_o^{O_v(s)}$ 做同样的计算

  * 变量多项式约束检查：

    $e(g_l^{L_p},g^{α_l}) = e(g_l^{L'_p},g)$，对 $g_r^{R_p}$ 和 $g_o^{O_p}$ 做同样的计算

  * 变量值一致性检查：

    $e(g_l^{L_p}g_r^{R_p}g_o^{O_p},h^{βγ}) = e(g^Z,g^γ)$

  * 有效计算检查：

    $e(g_l^{L_v(s)}g_l^{L_p},g_r^{R_v(s)}g_r^{R_p}) =e(g_o^t,g^h)e(g_o^{O_v(s)}g_o^{O_p},g)$

> 注意：根据协议（**单个变量操作数多项式** 的章节）的性质，由多项式 *l<sub>0</sub>(x),r<sub>0</sub>(x),o<sub>0</sub>(x)* 表示的值 1 已在相应的运算中具备了合适的值，因此不需要再赋值了。
>
> 注意：验证者将不得不在验证步骤中做额外的工作，使得赋值的变量成比例。

**这实际上是把一些变量从证明者手中拿到验证者的手中，并同时保持等式相等。** 因而只有当证明者和验证者的输入中使用相同值的时候， *有效计算*检查才依然成立。

1 这个值相当重要，它能够通过与任意一个常数项相乘来生成这个值（从选择的有限域上），例如，用 123 去乘以 *a*：

$\textcolor{green}{1 \cdot a} \times \textcolor{blue}{123 \cdot v_{one}} = \textcolor{red}{1 \cdot r}$

> 译者注：这里将原本由证明者赋值的一些变量改为由拿到验证者赋值，使得证明者不得不与验证者保持相同的输入。这不仅解决了 Verifier 参数输入的问题，也间接解决了常数赋值的问题。  
