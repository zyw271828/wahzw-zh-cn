# 加密值的乘法

配对操作（双线性映射）是一个数学结构，表示为函数  *e(g,g)*，它给定一个数据集中的两个加密的输入（即 *g<sup>a</sup>, g<sup>b</sup>* ），可以将他们确定性地映射到另一组不同的输出数据集上的它们的乘积，即 *e(g<sup>a</sup>, g<sup>b</sup>) = e(g, g)<sup>ab</sup>*：

![img](./img/2/1*0Qnz6c35UV1bv7uk620qrw.png)

因为源数据集和输出数据集（通常被称为一个 group）是不同的，所以一个配对的结果不能用做其他配对计算的输入。我们可以将输出集（也称为“目标集”）视为“不同的宇宙”。因而我们不能用另一个加密值乘以结果，而且配对这个名称本身也表明了，我们一次只能将两个加密值相乘。

> 译者注：换句话说，配对只支持 x *y 这种两个值的乘法，但不支持三个或以上的值相乘，比如不支持 x* y * z。

在某种意义上，这个类似于一个哈希函数，他将所有可能的输入值映射到可能的输出值的集合中的一个元素上，通常情况下这个过程是不可逆的。

*注意：乍一眼看过去，这个限制可能会阻碍相关功能的实现，但在 zk-SNARK 中这反而是保证安全模式的最重要性质，参见 **备注 3.3**。*

配对函数 *e*(*g*,*g*) 可以初步（严格来说是不对的）地类比成“交换”每一个输出的基数和指数的操作，使得基数 *g* 在交换过程中被修改成了指数的方式，即 *g<sup>a</sup> → a<sup>g</sup>* 。"被转换"的两个输入一起被修改了，这样原始值 *a* 和 *b* 就在同一个指数下相乘了，即：

$e(g^a,g^b) =a^g \cdot b^g =(ab)^g$

因而因为基数在“转换”中被修改了，所以在另一个配对中不能再使用这个结果 (*ab*)**ᵍ** （即：*e*((*ab*)*ᵍ*, g*ᵈ*)）构造出想要的加密乘积 *abd* 了。配对的核心性质可以表示成下面的等式：

$e(g^a,g^b) =r(g^b,g^a)=e(g^{ab},g^1)=e(g^1,g^{ab}) =e(g^1,g^a)^b =e(g^1,g^1)^{ab}$

严格来讲一个配对的结果是在目标集的一个不同生成元 *g* 下对原始值乘积的加密，即 *e*(*g*ᵃ, *g* *ᵇ*) = *gᵃᵇ*。因而它具备同态加密的性质，也就是说我们可以把乘法配对的加密乘积放到一起：

$e(g^a,g^b) \cdot e(g^c, g^d) = g^{ab} \cdot g^{cd} =g^{ab+cd} =r(g,g)^{ab+cd}$

> 注意：配对操作是通过改变椭圆曲线来实现这些性质的，现在我们用的符号  gⁿ 就代表曲线上一个由生成元自相加了 n  次的点，而不是我们前面用到的乘法群生成元。

 [[DBS04](https://medium.com/@imolfar/why-and-how-zk-snark-works-3-non-interactivity-distributed-setup-c0310c0e5d1c#0ea5)] 这个综述提供了学习配对的出发点。
