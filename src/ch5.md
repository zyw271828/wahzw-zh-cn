# 结论

我们最终完成了一个允许证明计算的有效协议：

* 简明 (Succinctly) —— 独立于计算量，证明是恒定的，小尺寸的
* 非交互性 (Non-interactive) —— 证明只要一经计算就可以在不直接与证明者交互的前提下使任意数量的验证者确信
* 可论证的知识 (with Argument of Knowledge) —— 对于陈述是正确的这点有不可忽略的概率，即无法构造假证据；并且证明者知道正确陈述的对应值（即：证据），例如，如果陈述是 “B 是 sha256(a) 的结果” 那么就说明证明者知道一些值 a 能够使得 B = sha256(a) 成立，因为 B 只能够通过 a 的知识计算出来，换句话说就是无法通过 B 来反算出 a（假定 a 的熵足够）。
* 陈述有不可忽略的概率是正确的 (译者注：这里指Soundness可靠性)，即，构造假证据是不可行的
* *零知识*( zero-knowledge)  —— 很“难”从证明中提取任何知识，即，它与随机数无法区分。

> 译者注：所谓Argument——论证，区别于 Proof —— 证明。Pinocchio 协议是 Argument 而非 Proof。这是因为 Pinocchio的可靠性是 Computational Soundness，Statistical ZK，这一类的证明系统被称为 Argument。所谓的 Computational Soundness 暗含了这样的事实：如果证明者计算能力足够强大的话，可以破坏可靠性。

基于多项式的特殊性质，模运算，同态加密，椭圆曲线密码学，加密配对和发明者的聪明才智才使得这个协议得以实现。

这个协议证明了一个特殊有限执行机制的计算，即在一次运算中可以将几乎任意数量的变量加在一起但是只能执行一次乘法，因而就有机会优化程序以有效地利用这种特性的同时也使用这个结构最大限度地减少计算次数。

为了验证一个证明， **验证者并不需要知道所有的秘密数据，这一点很关键**，这就使得任何人都可以以非交互式方式发布和使用正确构造的 *verification key*。这一点与只能让一个参与者确信证明的"指定验证者"方案相反，因而它的信任是不可转移的。在 *zkSNARK* 中，如果不可信或由单方生成密钥对，则可以实现这个属性。

零知识证明构造领域正在不断发展，包括引入了优化（[Ben+13, Gro16, GM17]），改进例如可更新的 *proving key* 和 *verification key*（[Gro+18]），以及新的构造方法（Bulletproofs [Bün+17], ZK-STARK [Ben+18], Sonic [Mal+19]）。

> 译者注：至此,本系列文章的介绍已经全部结束，大家是不是已经对zkSNARK协议（Pinocchio 协议）了如指掌了？其实任何复杂的协议掌握了核心思想，都可以抽丝剥茧将其变得通俗易懂。
>
> 零知识证明的学习还有很长的路要走，本文只是一个入门的资料，正如文章中所述，零知识证明构造领域正在不断发展，不断的有新的研究突破呈现在我们面前。这是一个非常有趣的领域，后续也非常欢迎小伙伴跟我们一起继续学习和研究零知识证明技术。
>
> 再次感谢 Maksym Petkus 大神的分享和授权。文章翻译存在不足之处，欢迎纠正，补充，指导。
