# 结论

我们最终得到了一个允许证明计算的有效协议：

* 简洁（Succinctly）——与计算量无关，证明的大小是恒定且小的
* 非交互式（Non-Interactively）——只要计算出证明，就可以用来说服任意数量的验证者，他们无需与证明者直接交互
* 有论证的知识（With Argumented Knowledge）——陈述正确的概率不可忽略，即假证明是不可行的；此外，证明者*知道*真实陈述的相应值（即证据），例如，如果陈述是「\\(B\\) 是 \\(\mathrm{sha256}(a)\\) 的结果」，那么就说明证明者知道某个 \\(a\\) 使得 \\(B = \mathrm{sha256}(a)\\) 成立，这一点很有用，因为 \\(B\\) 只能根据 \\(a\\) 的知识计算出来，并且仅从 \\(B\\) 计算出 \\(a\\) 是不可行的（假设 \\(a\\) 有足够的熵）
* 在*零知识*中（In *Zero-Knowledge*）——从证明中提取任何知识都是不可行的，即它与随机无法区分

> 译者注：论证（Argument）与证明（Proof）不同，Pinocchio 协议是论证而非证明。这是因为 Pinocchio 的可靠性是计算可靠性（Computational Soundness）、统计零知识（Statistical Zero-Knowledge），这一类的证明系统被称为论证。计算可靠性暗含了一种事实：如果证明者的计算能力足够强，可以破坏可靠性。

由于多项式的独特性质、模算术、同态加密、椭圆曲线密码学、密码学配对和发明者的独创性，这个协议才得以实现。

该协议证明了唯一的有限执行机计算的正确性，它在一次运算中可以将几乎任意数量的变量相加，但只能执行一次乘法。因此，有机会优化程序以有效利用这种特殊性，以及使用最小化运算数量的结构。

重要的是，验证者不必知道任何秘密数据来验证证明，任何人都可以用非交互的方式发布和使用正确构造的验证密钥。这与证明只能说服一方的「指定验证者（Designated Verifier）」方案相反，后者是不可转让的。在 *zk-SNARK* 中，我们可以在不可信或单方生成密钥对的情况下实现可转让属性。

零知识证明结构领域正在不断发展，包括优化（[[Ben+13](./references.md#Ben+13); [Gro16](./references.md#Gro16); [GM17](./references.md#GM17)]）、可更新的证明和验证密钥等改进（[[Gro+18](./references.md#Gro+18)]），以及新的结构（Bulletproofs [[Bün+17](./references.md#Bün+17)]，ZK-STARK [[Ben+18](./references.md#Ben+18)]，Sonic [[Mal+19](./references.md#Mal+19)]）。

## 致谢

我们感谢 Mary Maller 和 Andrew Miller 对这篇文章提出的宝贵意见。
